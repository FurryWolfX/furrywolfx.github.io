<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>算法专题：树 | Wolfx's Notebook</title>
    <meta name="description" content="Wolfx's Notebook">
    <meta name="generator" content="VitePress v1.1.4">
    <link rel="preload stylesheet" href="/assets/style.BHgQ4reG.css" as="style">
    
    <script type="module" src="/assets/app.BkRlDB1i.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.CAfrS5LL.js">
    <link rel="modulepreload" href="/assets/chunks/framework.VzvPGsLx.js">
    <link rel="modulepreload" href="/assets/docs_leetcode_thinkings_tree.md.BjIvGzm_.lean.js">
    <meta name="version" content="4.1 (framework-1.1.4)">
    <link rel="icon" href="/logo.png">
    <script id="check-dark-mode">document.documentElement.classList.add("dark");</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-da40f255><!--[--><!--]--><!--[--><span tabindex="-1" data-v-95261012></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-95261012> Skip to content </a><!--]--><!----><header class="VPNav" data-v-da40f255 data-v-f27a41cd><div class="VPNavBar top" data-v-f27a41cd data-v-62b39ba3><div class="wrapper" data-v-62b39ba3><div class="container" data-v-62b39ba3><div class="title" data-v-62b39ba3><div class="VPNavBarTitle" data-v-62b39ba3 data-v-6e5839e0><a class="title" href="/" data-v-6e5839e0><!--[--><!--]--><!----><span data-v-6e5839e0>Wolfx&#39;s Notebook</span><!--[--><!--]--></a></div></div><div class="content" data-v-62b39ba3><div class="content-body" data-v-62b39ba3><!--[--><!--]--><div class="VPNavBarSearch search" data-v-62b39ba3><!--[--><!----><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-62b39ba3 data-v-18caf788><span id="main-nav-aria-label" class="visually-hidden" data-v-18caf788>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-18caf788 data-v-74b47290><!--[--><span data-v-74b47290>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/docs/" tabindex="0" data-v-18caf788 data-v-74b47290><!--[--><span data-v-74b47290>Notes</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/ohos.html" tabindex="0" data-v-18caf788 data-v-74b47290><!--[--><span data-v-74b47290>OpenHarmony</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/leetcode.html" tabindex="0" data-v-18caf788 data-v-74b47290><!--[--><span data-v-74b47290>LeetCode</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/about.html" tabindex="0" data-v-18caf788 data-v-74b47290><!--[--><span data-v-74b47290>About</span><!--]--></a><!--]--><!--]--></nav><!----><!----><!----><div class="VPFlyout VPNavBarExtra extra" data-v-62b39ba3 data-v-2efb0164 data-v-27e530ef><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-27e530ef><span class="vpi-more-horizontal icon" data-v-27e530ef></span></button><div class="menu" data-v-27e530ef><div class="VPMenu" data-v-27e530ef data-v-d444d8fe><!----><!--[--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-62b39ba3 data-v-99d679c4><span class="container" data-v-99d679c4><span class="top" data-v-99d679c4></span><span class="middle" data-v-99d679c4></span><span class="bottom" data-v-99d679c4></span></span></button></div></div></div></div><div class="divider" data-v-62b39ba3><div class="divider-line" data-v-62b39ba3></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-da40f255 data-v-17247140><div class="container" data-v-17247140><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-17247140 data-v-79a59036><button data-v-79a59036>返回顶部</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-da40f255 data-v-6ac16ad2><div class="VPDoc has-aside" data-v-6ac16ad2 data-v-800b61a0><!--[--><!--]--><div class="container" data-v-800b61a0><div class="aside" data-v-800b61a0><div class="aside-curtain" data-v-800b61a0></div><div class="aside-container" data-v-800b61a0><div class="aside-content" data-v-800b61a0><div class="VPDocAside" data-v-800b61a0 data-v-55f8d03c><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" role="navigation" data-v-55f8d03c data-v-ee375941><div class="content" data-v-ee375941><div class="outline-marker" data-v-ee375941></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-ee375941>大纲(Outline)</div><ul class="VPDocOutlineItem root" data-v-ee375941 data-v-e3561caa><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-55f8d03c></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-800b61a0><div class="content-container" data-v-800b61a0><!--[--><!--]--><main class="main" data-v-800b61a0><div style="position:relative;" class="vp-doc _docs_leetcode_thinkings_tree" data-v-800b61a0><div><h1 id="算法专题-树" tabindex="-1">算法专题：树 <a class="header-anchor" href="#算法专题-树" aria-label="Permalink to &quot;算法专题：树&quot;">​</a></h1><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/feb6b31010e89e89e0771f7a448c53e2.jpg" alt=""></p><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>计算机的数据结构是对现实世界物体间关系的一种抽象。比如家族的族谱，公司架构中的人员组织关系，电脑中的文件夹结构，html 渲染的 dom 结构等等，这些有层次关系的结构在计算机领域都叫做树。</p><p>首先明确一下，树其实是一种逻辑结构。比如笔者平时写复杂递归的时候，尽管笔者做的题目不是树，也会画一个递归树帮助自己理解。</p><blockquote><p>树是一种重要的思维工具</p></blockquote><p>以最简单的计算 fibonacci 数列为例：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">n</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>很明显它的入参和返回值都不是树，但是却不影响我们用树的思维去思考。</p><p>继续回到上面的代码，根据上面的代码可以画出如下的递归树。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/f093d78f7e055a0f0e3eebfd6a21c0a9.jpg" alt=""></p><p>其中树的边表示的是返回值，树节点表示的是需要计算的值，即 fn(n）。</p><p>以计算 5 的 fibbonacci 为例，过程大概是这样的（动图演示）：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/0af735a3c7e2b55ed96604a515501ab0.gif" alt=""></p><p><strong>这其实就是一个树的后序遍历</strong>，你说树（逻辑上的树）是不是很重要？关于后序遍历咱们后面再讲，现在大家知道是这么回事就行。</p><p>大家也可以去 <a href="https://recursion.now.sh/" target="_blank" rel="noreferrer">递归可视化网站</a> 查看上面算法的单步执行效果。当然这个网站还有更多的算法的动画演示。</p><blockquote><p>上面的图箭头方向是为了方便大家理解。其实箭头方向变成向下的才是真的树结构。</p></blockquote><p>广义的树真的很有用，但是它范围太大了。 本文所讲的树的题目是比较狭隘的树，指的是输入（参数）或者输出（返回值）是树结构的题目。</p><h3 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h3><blockquote><p>树的基本概念难度都不大，为了节省篇幅，我这里简单过一下。对于你不熟悉的点，大家自行去查找一下相关资料。我相信大家也不是来看这些的，大家应该想看一些不一样的东西，比如说一些做题的套路。</p></blockquote><p>树是一种非线性数据结构。树结构的基本单位是节点。节点之间的链接，称为分支（branch）。节点与分支形成树状，结构的开端，称为根（root），或根结点。根节点之外的节点，称为子节点（child）。没有链接到其他子节点的节点，称为叶节点（leaf）。如下图是一个典型的树结构：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/ff2fcfab1f3cda5e2563b2355e343696.jpg" alt=""></p><p>每个节点可以用以下数据结构来表示：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Node {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	value: any;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 当前节点的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	children: Array</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 指向其儿子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>其他重要概念：</p><ul><li>树的高度：节点到叶子节点的最大值就是其高度。</li><li>树的深度：高度和深度是相反的，高度是从下往上数，深度是从上往下。因此根节点的深度和叶子节点的高度是 0。</li><li>树的层：根开始定义，根为第一层，根的孩子为第二层。</li><li>二叉树，三叉树，... N 叉树，由其子节点最多可以有几个决定，最多有 N 个就是 N 叉树。</li></ul><h3 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h3><p>二叉树是树结构的一种，两个叉就是说每个节点<strong>最多</strong>只有两个子节点，我们习惯称之为左节点和右节点。</p><blockquote><p>注意这个只是名字而已，并不是实际位置上的左右</p></blockquote><p>二叉树也是我们做算法题最常见的一种树，因此我们花大篇幅介绍它，大家也要花大量时间重点掌握。</p><p>二叉树可以用以下数据结构表示：</p><div class="language-c vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Node {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	value: any;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 当前节点的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	left: Node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> null;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 左儿子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	right: Node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> null;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 右儿子</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="二叉树分类" tabindex="-1">二叉树分类 <a class="header-anchor" href="#二叉树分类" aria-label="Permalink to &quot;二叉树分类&quot;">​</a></h4><ul><li>完全二叉树</li><li>满二叉树</li><li>二叉搜索树</li><li><a href="./balanced-tree.html">平衡二叉树</a></li><li>红黑树</li><li>...</li></ul><h4 id="二叉树的表示" tabindex="-1">二叉树的表示 <a class="header-anchor" href="#二叉树的表示" aria-label="Permalink to &quot;二叉树的表示&quot;">​</a></h4><ul><li>链表存储</li><li>数组存储。非常适合完全二叉树</li></ul><h2 id="树题难度几何" tabindex="-1">树题难度几何？ <a class="header-anchor" href="#树题难度几何" aria-label="Permalink to &quot;树题难度几何？&quot;">​</a></h2><p>很多人觉得树是一个很难的专题。实际上，只要你掌握了诀窍，它并没那么难。</p><p>从官方的难度标签来看，树的题目处于困难难度的一共是 14 道， 这其中还有 1 个标着树的标签但是却是图的题目，因此困难率是 13 / 175 ，也就是 7.4 % 左右。如果排除上锁的 5 道，困难的只有 9 道。大多数困难题，相信你看完本节的内容，也可以做出来。</p><p>从通过率来看，只有<strong>不到三分之一</strong>的题目平均通过率在 50% 以下，其他（绝大多数的题目）通过率都是 50%以上。50% 是一个什么概念呢？这其实很高了。举个例子来说， BFS 的平均通过率差不多在 50%。 而大家认为比较难的二分法和动态规划的平均通过率差不多 40%。</p><p>大家不要对树有压力， 树和链表一样是相对容易的专题，今天给大家带来了一个口诀<strong>一个中心，两个基本点，三种题型，四个重要概念，七个技巧</strong>，帮助你克服树这个难关。</p><h2 id="一个中心" tabindex="-1">一个中心 <a class="header-anchor" href="#一个中心" aria-label="Permalink to &quot;一个中心&quot;">​</a></h2><p>一个中心指的是<strong>树的遍历</strong>。整个树的专题只有一个中心点，那就是树的遍历，大家务必牢牢记住。</p><p>不管是什么题目，核心就是树的遍历，这是一切的基础，不会树的遍历后面讲的都是白搭。</p><p>其实树的遍历的本质就是去把树里边儿的每个元素都访问一遍（任何数据结构的遍历不都是如此么？）。但怎么访问的？我不能直接访问叶子节点啊，我必须得从根节点开始访问，然后根据子节点指针访问子节点，但是子节点有多个（二叉树最多两个）方向，所以又有了先访问哪个的问题，这造成了不同的遍历方式。</p><blockquote><p>左右子节点的访问顺序通常不重要，极个别情况下会有一些微妙区别。比如说我们想要访问一棵树的最左下角节点，那么顺序就会产生影响，但这种题目会比较少一点。</p></blockquote><p>而遍历不是目的，遍历是为了更好地做处理，这里的处理包括搜索，修改树等。树虽然只能从根开始访问，但是我们可以<strong>选择</strong>在访问完毕回来的时候做处理，还是在访问回来之前做处理，这两种不同的方式就是<strong>后序遍历</strong>和<strong>先序遍历</strong>。</p><blockquote><p>关于具体的遍历，后面会给大家详细讲，现在只要知道这些遍历是怎么来的就行了。</p></blockquote><p>而树的遍历又可以分为两个基本类型，分别是深度优先遍历和广度优先遍历。这两种遍历方式并不是树特有的，但却伴随树的所有题目。值得注意的是，这两种遍历方式只是一种逻辑而已，因此理论可以应用于任何数据结构，比如 <a href="./../0365.water-and-jug-problem.html">365. 水壶问题</a> 中，就可以对水壶的状态使用广度优先遍历，而水壶的状态可以用<strong>一个二元组</strong>来表示。</p><blockquote><p>遗憾的是这道题的广度优先遍历解法在 LeetCode 上提交会超时</p></blockquote><h3 id="树的遍历迭代写法" tabindex="-1">树的遍历迭代写法 <a class="header-anchor" href="#树的遍历迭代写法" aria-label="Permalink to &quot;树的遍历迭代写法&quot;">​</a></h3><p>很多小朋友表示二叉树前中后序的递归写法没问题，但是迭代就写不出来，问我有什么好的方法没有。</p><p>这里就给大家介绍一种写迭代遍历树的实操技巧，统一三种树的遍历方式，包你不会错，这个方法叫做双色标记法。 如果你会了这个技巧，那么你平时练习大可<strong>只用递归</strong>。然后面试的时候，真的要求用迭代或者是对性能有特别要求的那种题目，那你就用我的方法套就行了，下面我来详细讲一下这种方法。</p><p>我们知道垃圾回收算法中，有一种算法叫三色标记法。 即：</p><ul><li>用白色表示尚未访问</li><li>灰色表示尚未完全访问子节点</li><li>黑色表示子节点全部访问</li></ul><p>那么我们可以模仿其思想，使用双色标记法来统一三种遍历。</p><p>其核心思想如下：</p><ul><li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><p>使用这种方法实现的中序遍历如下：</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inorderTraversal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; List[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        WHITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GRAY</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        stack </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WHITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, root)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            color, node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> stack.pop()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> WHITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                stack.append((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WHITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node.right))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                stack.append((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GRAY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                stack.append((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WHITE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, node.left))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                res.append(node.val)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>可以看出，实现上 WHITE 就表示的是递归中的第一次进入过程，Gray 则表示递归中的从叶子节点返回的过程。 因此这种迭代的写法更接近递归写法的本质。</p><p>如要<strong>实现前序、后序遍历，也只需要调整左右子节点的入栈顺序即可，其他部分是无需做任何变化</strong>。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/decf4f5818b6021dc5dcd1f972ef83da.jpg" alt=""> （前中后序遍历只需要调整这三句话的位置即可）</p><blockquote><p>注：这张示意图的前序和后序画反了</p></blockquote><p>可以看出使用三色标记法，其写法类似递归的形式，因此便于记忆和书写。</p><p>有的同学可能会说，这里的每一个节点都会入栈出栈两次，相比普通的迭代入栈和出栈次数整整加了一倍，这性能可以接受么？我要说的是这种时间和空间的增加仅仅是常数项的增加，大多数情况并不会都程序造成太大的影响。 除了有时候比赛会比较恶心人，会<strong>卡常</strong>（卡常是指通过计算机原理相关的、与理论复杂度无关的方法对代码运行速度进行优化)。反过来看，大家写的代码大多数是递归，要知道递归由于内存栈的开销，性能通常比这里的二色标记法更差才对， 那为啥不用一次入栈的迭代呢？更极端一点，为啥大家不都用 morris 遍历 呢？</p><blockquote><p>morris 遍历 是可以在常数的空间复杂度完成树的遍历的一种算法。</p></blockquote><p>我认为在大多数情况下，大家对这种细小的差异可以不用太关注。另外如果这种遍历方式完全掌握了，再根据递归的思想去写一次入栈的迭代也不是难事。 无非就是调用函数的时候入栈，函数 return 时候出栈罢了。更多二叉树遍历的内容，大家也可以访问我之前写的专题<a href="./binary-tree-traversal.html">《二叉树的遍历》</a>。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>简单总结一下，树的题目一个中心就是树的遍历。树的遍历分为两种，分别是深度优先遍历和广度优先遍历。关于树的不同深度优先遍历（前序，中序和后序遍历）的迭代写法是大多数人容易犯错的地方，因此我介绍了一种统一三种遍历的方法 - 二色标记法，这样大家以后写迭代的树的前中后序遍历就再也不用怕了。如果大家彻底熟悉了这种写法，再去记忆和练习一次入栈甚至是 Morris 遍历即可。</p><p>其实用一次入栈和出栈的迭代实现递归也很简单，无非就是还是用递归思想，只不过你把递归体放到循环里边而已。大家可以在熟悉递归之后再回头看看就容易理解了。树的深度遍历的递归技巧，我们会在后面的《两个基本点》部分讲解。</p><h2 id="两个基本点" tabindex="-1">两个基本点 <a class="header-anchor" href="#两个基本点" aria-label="Permalink to &quot;两个基本点&quot;">​</a></h2><p>上面提到了树的遍历有两种基本方式，分别是<strong>深度优先遍历（以下简称 DFS）和广度优先遍历（以下简称 BFS），这就是两个基本点</strong>。这两种遍历方式下面又会细分几种方式。比如 <strong>DFS 细分为前中后序遍历， BFS 细分为带层的和不带层的</strong>。</p><p><strong>DFS 适合做一些暴力枚举的题目，DFS 如果借助函数调用栈，则可以轻松地使用递归来实现。</strong></p><h3 id="bfs-不是-层次遍历" tabindex="-1">BFS 不是 层次遍历 <a class="header-anchor" href="#bfs-不是-层次遍历" aria-label="Permalink to &quot;BFS 不是 层次遍历&quot;">​</a></h3><p>而 BFS 适合求最短距离，这个和层次遍历是不一样的，很多人搞混。这里强调一下，层次遍历和 BFS 是<strong>完全不一样</strong>的东西。</p><p>层次遍历就是一层层遍历树，按照树的层次顺序进行访问。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/a450ce4de45768a9ecea4dce02d87ed3.jpg" alt=""> （层次遍历图示）</p><p><strong>BFS 的核心在于求最短问题时候可以提前终止，这才是它的核心价值，层次遍历是一种不需要提前终止的 BFS 的副产物</strong>。这个提前终止不同于 DFS 的剪枝的提前终止，而是找到最近目标的提前终止。比如我要找距离最近的目标节点，BFS 找到目标节点就可以直接返回。而 DFS 要穷举所有可能才能找到最近的，这才是 BFS 的核心价值。实际上，我们也可以使用 DFS 实现层次遍历的效果，借助于递归，代码甚至会更简单。</p><blockquote><p>如果找到任意一个满足条件的节点就好了，不必最近的，那么 DFS 和 BFS 没有太大差别。同时为了书写简单，我通常会选择 DFS。</p></blockquote><p>以上就是两种遍历方式的简单介绍，下面我们对两者进行一个详细的讲解。</p><h3 id="深度优先遍历" tabindex="-1">深度优先遍历 <a class="header-anchor" href="#深度优先遍历" aria-label="Permalink to &quot;深度优先遍历&quot;">​</a></h3><p>深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止，属于<strong>盲目搜索</strong>。</p><p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。因发明「深度优先搜索算法」，约翰 · 霍普克洛夫特与罗伯特 · 塔扬在 1986 年共同获得计算机领域的最高奖：图灵奖。</p><p>截止目前（2020-02-21），深度优先遍历在 LeetCode 中的题目是 129 道。在 LeetCode 中的题型绝对是超级大户了。而对于树的题目，我们基本上都可以使用 DFS 来解决，甚至我们可以基于 DFS 来做层次遍历，而且由于 DFS 可以基于递归去做，因此算法会更简洁。 在对性能有很高要求的场合，我建议你使用迭代，否则尽量使用递归，不仅写起来简单快速，还不容易出错。</p><p>DFS 图解：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/0df6edfe467803d1f22b99eea1788d89.gif" alt="binary-tree-traversal-dfs"></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/depth-first-search" target="_blank" rel="noreferrer">https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/depth-first-search</a>)</p><h4 id="算法流程" tabindex="-1">算法流程 <a class="header-anchor" href="#算法流程" aria-label="Permalink to &quot;算法流程&quot;">​</a></h4><ol><li>首先将根节点放入<strong>stack</strong>中。</li><li>从<em>stack</em>中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它某一个尚未检验过的直接子节点加入<strong>stack</strong>中。</li><li>重复步骤 2。</li><li>如果不存在未检测过的直接子节点。将上一级节点加入<strong>stack</strong>中。 重复步骤 2。</li><li>重复步骤 4。</li><li>若<strong>stack</strong>为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li></ol><p><strong>这里的 stack 可以理解为自己实现的栈，也可以理解为调用栈。如果是调用栈的时候就是递归，如果是自己实现的栈的话就是迭代。</strong></p><h4 id="算法模板" tabindex="-1">算法模板 <a class="header-anchor" href="#算法模板" aria-label="Permalink to &quot;算法模板&quot;">​</a></h4><p>一个典型的通用的 DFS 模板可能是这样的：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> visited</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足特定条件）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 返回结果 or 退出搜索空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	visited[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 将当前状态标为已搜索</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (根据i能到达的下个状态j) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (!</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">visited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">j</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果状态j没有被搜索过</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">			dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>上面的 visited 是为了防止由于环的存在造成的死循环的。 而我们知道树是不存在环的，因此树的题目大多数不需要 visited，除非你对树的结构做了修改，比如就左子树的 left 指针指向自身，此时会有环。再比如 <a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noreferrer">138. 复制带随机指针的链表</a> 这道题需要记录已经复制的节点，这些需要记录 visited 信息的树的题目<strong>少之又少</strong>。</p><p>因此一个树的 DFS 更多是：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足特定条件）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 返回结果 or 退出搜索空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (const child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.children) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">child</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>而几乎所有的题目几乎都是二叉树，因此下面这个模板更常见。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足特定条件）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 返回结果 or 退出搜索空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>而我们不同的题目除了 if (满足特定条件部分不同之外)，还会写一些特有的逻辑，这些逻辑写的位置不同，效果也截然不同。那么位置不同会有什么影响，什么时候应该写哪里呢？接下来，我们就聊聊两种常见的 DFS 方式。</p><h4 id="两种常见分类" tabindex="-1">两种常见分类 <a class="header-anchor" href="#两种常见分类" aria-label="Permalink to &quot;两种常见分类&quot;">​</a></h4><p>前序遍历和后序遍历是最常见的两种 DFS 方式。而另外一种遍历方式 （中序遍历）一般用于平衡二叉树，这个我们后面的<strong>四个重要概念</strong>部分再讲。</p><h5 id="前序遍历" tabindex="-1">前序遍历 <a class="header-anchor" href="#前序遍历" aria-label="Permalink to &quot;前序遍历&quot;">​</a></h5><p>如果你的代码大概是这么写的（注意主要逻辑的位置）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足特定条件）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 返回结果 or 退出搜索空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 主要逻辑</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>那么此时我们称为前序遍历。</p><h5 id="后序遍历" tabindex="-1">后序遍历 <a class="header-anchor" href="#后序遍历" aria-label="Permalink to &quot;后序遍历&quot;">​</a></h5><p>而如果你的代码大概是这么写的（注意主要逻辑的位置）：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足特定条件）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 返回结果 or 退出搜索空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 主要逻辑</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>那么此时我们称为后序遍历。</p><p>值得注意的是， 我们有时也会会写出这样的代码：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">root</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (满足特定条件）{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 返回结果 or 退出搜索空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 做一些事</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 做另外的事</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>如上代码，我们在进入和退出左右子树的时候分别执行了一些代码。那么这个时候，是前序遍历还是后序遍历呢？实际上，这属于混合遍历了。不过我们这里只考虑<strong>主逻辑</strong>的位置，关键词是<strong>主逻辑</strong>。</p><p>如果代码主逻辑在左右子树之前执行，那么就是前序遍历。如果代码主逻辑在左右子树之后执行，那么就是后序遍历。关于更详细的内容， 我会在<strong>七个技巧</strong> 中的<strong>前后遍历</strong>部分讲解，大家先留个印象，知道有着两种方式就好。</p><h5 id="递归遍历的学习技巧" tabindex="-1">递归遍历的学习技巧 <a class="header-anchor" href="#递归遍历的学习技巧" aria-label="Permalink to &quot;递归遍历的学习技巧&quot;">​</a></h5><p>上面的《一个中心》部分，给大家介绍了一种干货技巧《双色遍历》统一三种遍历的迭代写法。 而树的遍历的递归的写法其实大多数人都没问题。为什么递归写的没问题，用栈写迭代就有问题呢? 本质上其实还是对递归的理解不够。今天给大家介绍一种练习递归的技巧。其实文章开头也提到了，那就是画图 + 手动代入。有的同学不知道怎么画，这里我抛砖引玉分享一下我学习递归的画法。</p><p>比如我们要前序遍历一棵这样的树：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    4   5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/1e9dcaa7b0ea0c2857083c5048669d78.jpg" alt=""></p><p>图画的还算比较清楚， 就不多解释了。大家遇到题目多画几次这样的递归图，慢慢就对递归有感觉了。</p><h3 id="广度优先遍历" tabindex="-1">广度优先遍历 <a class="header-anchor" href="#广度优先遍历" aria-label="Permalink to &quot;广度优先遍历&quot;">​</a></h3><p>树的遍历的两种方式分别是 DFS 和 BFS，刚才的 DFS 我们简单过了一下前序和后序遍历，对它们有了一个简单印象。这一小节，我们来看下树的另外一种遍历方式 - BFS。</p><p>BFS 也是图论中算法的一种，不同于 DFS， BFS 采用横向搜索的方式，在数据结构上通常采用队列结构。 注意，DFS 我们借助的是栈来完成，而这里借助的是队列。</p><p>BFS 比较适合找<strong>最短距离/路径</strong>和<strong>某一个距离的目标</strong>。比如<code>给定一个二叉树，在树的最后一行找到最左边的值。 </code>，此题是力扣 513 的原题。这不就是求距离根节点<strong>最远距离</strong>的目标么？ 一个 BFS 模板就解决了。</p><p>BFS 图解：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/cdf240f76c90dc6472505887fbea238a.gif" alt="binary-tree-traversal-bfs"></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/breadth-first-search" target="_blank" rel="noreferrer">https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/tree/breadth-first-search</a>)</p><h4 id="算法流程-1" tabindex="-1">算法流程 <a class="header-anchor" href="#算法流程-1" aria-label="Permalink to &quot;算法流程&quot;">​</a></h4><ol><li>首先将根节点放入队列中。</li><li>从队列中取出第一个节点，并检验它是否为目标。 <ul><li>如果找到目标，则结束搜索并回传结果。</li><li>否则将它所有尚未检验过的直接子节点加入队列中。</li></ul></li><li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</li><li>重复步骤 2。</li></ol><h4 id="算法模板-1" tabindex="-1">算法模板 <a class="header-anchor" href="#算法模板-1" aria-label="Permalink to &quot;算法模板&quot;">​</a></h4><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> visited</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Queue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	q.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(初始状态)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(q.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (visited[i]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i 是我们要找的目标) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 结果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i的可抵达状态j) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (j 合法) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				q.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(j)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 没找到</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="两种常见分类-1" tabindex="-1">两种常见分类 <a class="header-anchor" href="#两种常见分类-1" aria-label="Permalink to &quot;两种常见分类&quot;">​</a></h4><p>BFS 我目前使用的模板就两种，这两个模板可以解决所有的树的 BFS 问题。</p><p>前面我提到了“BFS 比较适合找<strong>最短距离/路径</strong>和<strong>某一个距离的目标</strong>”。 如果我需要求的是最短距离/路径，我是不关心我走到第几步的，这个时候可是用不标记层的目标。而如果我需要求距离某个节点距离等于 k 的所有节点，这个时候第几步这个信息就值得被记录了。</p><blockquote><p>小于 k 或者 大于 k 也是同理。</p></blockquote><h5 id="标记层" tabindex="-1">标记层 <a class="header-anchor" href="#标记层" aria-label="Permalink to &quot;标记层&quot;">​</a></h5><p>一个常见的 BFS 模板，代入题目只需要根据题目微调即可。</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.deque([root])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 记录层数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        steps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 需要返回的节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 队列不空，生命不止！</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(queue)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 遍历当前层的所有节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(size):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue.popleft()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (step </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k) ans.append(node)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.right:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    queue.append(node.right)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.left:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    queue.append(node.left)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 遍历完当前层所有的节点后 steps + 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            steps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h5 id="不标记层" tabindex="-1">不标记层 <a class="header-anchor" href="#不标记层" aria-label="Permalink to &quot;不标记层&quot;">​</a></h5><p>不带层的模板更简单，因此大家其实只需要掌握带层信息的目标就够了。</p><p>一个常见的 BFS 模板，代入题目只需要根据题目微调即可。</p><div class="language-python vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(k):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        queue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.deque([root])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 队列不空，生命不止！</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue.popleft()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 由于没有记录 steps，因此我们肯定是不需要根据层的信息去判断的。否则就用带层的模板了。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node 是我们要找到的) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.right:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                queue.append(node.right)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.left:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                queue.append(node.left)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>以上就是 BFS 的两种基本方式，即带层和不带层，具体使用哪种看题目是否需要根据层信息做判断即可。</p><h3 id="小结-1" tabindex="-1">小结 <a class="header-anchor" href="#小结-1" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>树的遍历是后面所有内容的基础，而树的遍历的两种方式 DFS 和 BFS 到这里就简单告一段落，现在大家只要知道 DFS 和 BFS 分别有两种常见的方式就够了，后面我会给大家详细补充。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/6ff018cc5e460ecba86e006b6577c027.jpg" alt=""></p><h2 id="三种题型" tabindex="-1">三种题型 <a class="header-anchor" href="#三种题型" aria-label="Permalink to &quot;三种题型&quot;">​</a></h2><p>树的题目就三种类型，分别是：<strong>搜索类，构建类和修改类，而这三类题型的比例也是逐渐降低的</strong>，即搜索类的题目最多，其次是构建类，最后是修改类。这一点和链表有很大的不同，链表更多的是修改类。</p><p>接下来，给大家逐一讲解这三种题型。</p><h3 id="搜索类" tabindex="-1">搜索类 <a class="header-anchor" href="#搜索类" aria-label="Permalink to &quot;搜索类&quot;">​</a></h3><p>搜索类的题目是树的题目的绝对大头。而搜索类只有两种解法，那就是 DFS 和 BFS，下面分别介绍。</p><p>几乎所有的搜索类题目都可以方便地使用递归来实现，关于递归的技巧会在<strong>七个技巧中的单/双递归</strong>部分讲解。还有一小部分使用递归不好实现，我们可以使用 BFS，借助队列轻松实现，比如最经典的是求二叉树任意两点的距离，树的距离其实就是最短距离，因此可以用 BFS 模板解决。这也是为啥我说<strong>DFS 和 BFS</strong>是树的题目的两个基本点的原因。</p><p>所有搜索类的题目只要把握三个核心点，即<strong>开始点</strong>，<strong>结束点</strong> 和 <strong>目标</strong>即可。</p><h4 id="dfs-搜索" tabindex="-1">DFS 搜索 <a class="header-anchor" href="#dfs-搜索" aria-label="Permalink to &quot;DFS 搜索&quot;">​</a></h4><p>DFS 搜索类的基本套路就是从入口开始做 dfs，然后在 dfs 内部判断是否是结束点，这个结束点通常是<strong>叶子节点</strong>或<strong>空节点</strong>，关于结束这个话题我们放在<strong>七个技巧中的边界</strong>部分介绍，如果目标是一个基本值（比如数字）直接返回或者使用一个全局变量记录即可，如果是一个数组，则可以通过扩展参数的技巧来完成，关于扩展参数，会在<strong>七个技巧中的参数扩展</strong>部分介绍。 这基本就是搜索问题的全部了，当你读完后面的七个技巧，回头再回来看这个会更清晰。</p><p>套路模板：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 其中 path 是树的路径， 如果需要就带上，不需要就不带</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, path):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 空节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 叶子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.right: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path.append(root)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 逻辑可以写这里，此时是前序遍历</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.left)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.right)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 需要弹出，不然会错误计算。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 比如对于如下树：</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">              5</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">             / </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            4   8</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">           /   / </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          11  13  4</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         /  \    / </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        7    2  5   1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 如果不 pop，那么 5 -&gt; 4 -&gt; 11 -&gt; 2 这条路径会变成 5 -&gt; 4 -&gt; 11 -&gt; 7 -&gt; 2，其 7 被错误地添加到了 path</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path.pop()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 逻辑也可以写这里，此时是后序遍历</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 你想返回的数据</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>比如<a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noreferrer">剑指 Offer 34. 二叉树中和为某一值的路径</a> 这道题，题目是：<code>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</code> 这不就是从根节点开始，到叶子节点结束的所有路径<strong>搜索出来</strong>，挑选出和为目标值的路径么？这里的开始点是根节点， 结束点是叶子节点，目标就是路径。</p><p>对于求这种满足<strong>特定和</strong>的题目，我们都可以方便地使用<strong>前序遍历 + 参数扩展的形式</strong>，关于这个，我会在<strong>七个技巧中的前后序部分</strong>展开。</p><blockquote><p>由于需要找到所有的路径，而不仅仅是一条，因此这里适合使用回溯暴力枚举。关于回溯，可以参考我的 <a href="./backtrack.html">回溯专题</a></p></blockquote><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> pathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode, target: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; List[List[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]]:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backtrack</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes, path, cur, remain):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 空节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 叶子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.right:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> remain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.val:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    nodes.append((path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [cur.val]).copy())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 选择</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            path.append(cur.val)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 递归左右子树</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            backtrack(nodes, path, cur.left, remain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.val)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            backtrack(nodes, path, cur.right, remain </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.val)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 撤销选择</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            path.pop(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 入口，路径，目标值全部传进去，其中路径和path都是扩展的参数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        backtrack(ans, [], root, target)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>再比如：<a href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree/" target="_blank" rel="noreferrer">1372. 二叉树中的最长交错路径</a>，题目描述：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>选择二叉树中 任意 节点和一个方向（左或者右）。</span></span>
<span class="line"><span>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</span></span>
<span class="line"><span>改变前进方向：左变右或者右变左。</span></span>
<span class="line"><span>重复第二步和第三步，直到你在树中无法继续移动。</span></span>
<span class="line"><span>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>请你返回给定树中最长 交错路径 的长度。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>比如：</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/18256ce1f0adbff27caf88dbead8caf7.jpg" alt=""></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>此时需要返回 3</span></span>
<span class="line"><span>解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这不就是从任意节点<strong>开始</strong>，到任意节点<strong>结束</strong>的所有交错<strong>路径</strong>全部<strong>搜索出来</strong>，挑选出最长的么？这里的开始点是树中的任意节点，结束点也是任意节点，目标就是最长的交错路径。</p><p>对于入口是任意节点的题目，我们都可以方便地使用<strong>双递归</strong>来完成，关于这个，我会在<strong>七个技巧中的单/双递归部分</strong>展开。</p><p>对于这种交错类的题目，一个好用的技巧是使用 -1 和 1 来记录方向，这样我们就可以通过乘以 -1 得到另外一个方向。</p><blockquote><p><a href="./../0886.possible-bipartition.html">886. 可能的二分法</a> 和 <a href="./../0785.is-graph-bipartite.html">785. 判断二分图</a> 都用了这个技巧。</p></blockquote><p>用代码表示就是：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">next_direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur_direction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里我们使用双递归即可解决。 如果题目限定了只从根节点开始，那就可以用单递归解决了。值得注意的是，这里内部递归需要 cache 一下 ， 不然容易因为重复计算导致超时。</p><blockquote><p>我的代码是 Python，这里的 lru_cache 就是一个缓存，大家可以使用自己语言的字典模拟实现。</p></blockquote><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    @lru_cache</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root, dir):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dfs(root.left, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dfs(root.right, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dir</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> longestZigZag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dfs(root, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.dfs(root, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.longestZigZag(root.left), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.longestZigZag(root.right))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这个代码不懂没关系，大家只有知道搜索类题目的大方向即可，具体做法我们后面会介绍，大家留个印象就行。更多的题目以及这些技巧的详细使用方式放在<strong>七个技巧部分</strong>展开。</p><h4 id="bfs-搜索" tabindex="-1">BFS 搜索 <a class="header-anchor" href="#bfs-搜索" aria-label="Permalink to &quot;BFS 搜索&quot;">​</a></h4><p>这种类型相比 DFS，题目数量明显降低，套路也少很多。题目大多是求距离，套用我上面的两种 BFS 模板基本都可以轻松解决，这个不多介绍了。</p><h3 id="构建类" tabindex="-1">构建类 <a class="header-anchor" href="#构建类" aria-label="Permalink to &quot;构建类&quot;">​</a></h3><p>除了搜索类，另外一个大头是构建类。构建类又分为两种：普通二叉树的构建和二叉搜索树的构建。</p><h4 id="普通二叉树的构建" tabindex="-1">普通二叉树的构建 <a class="header-anchor" href="#普通二叉树的构建" aria-label="Permalink to &quot;普通二叉树的构建&quot;">​</a></h4><p>而普通二叉树的构建又分为三种：</p><ol><li>给你两种 DFS 的遍历的结果数组，让你构建出原始的树结构。比如根据先序遍历和后序遍历的数组，构造原始二叉树。 <ul><li><a href="./../0105.construct-binary-tree-from-inorder-and-postorder-traversal.html">105. 从前序与中序遍历序列构造二叉树</a></li><li><a href="./../0106.construct-binary-tree-from-preorder-and-inorder-traversal.html">106. 从中序与后序遍历序列构造二叉树</a></li><li><a href="./../0889.construct-binary-tree-from-preorder-and-postorder-traversal.html">889. 根据前序和后序遍历构造二叉树</a></li></ul></li></ol><blockquote><p>这种题目假设输入的遍历的序列中都不含重复的数字，想想这是为什么。</p></blockquote><ol><li>给你一个 BFS 的遍历的结果数组，让你构建出原始的树结构。</li></ol><p>最经典的就是 <a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noreferrer">剑指 Offer 37. 序列化二叉树</a>。我们知道力扣的所有的树表示都是使用数字来表示的，而这个数组就是一棵树的层次遍历结果，部分叶子节点的子节点（空节点）也会被打印。比如：[1,2,3,null,null,4,5]，就表示的是如下的一颗二叉树：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/2e72f61cf7c8c3d0be02e6bcb7ca0cab.jpg" alt=""></p><p>我们是如何根据这样的一个层次遍历结果构造出原始二叉树的呢？这其实就属于构造二叉树的内容，这个类型目前力扣就这一道题。这道题如果你彻底理解 BFS，那么就难不倒你。</p><ol start="3"><li>还有一种是给你描述一种场景，让你构造一个符合条件的二叉树。这种题和上面的没啥区别，套路简直不要太像，比如 <a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noreferrer">654. 最大二叉树</a>，我就不多说了，大家通过这道题练习一下就知道了。</li></ol><p>除了这种静态构建，还有一种很很罕见的动态构建二叉树的，比如 <a href="https://leetcode-cn.com/problems/complete-binary-tree-inserter/" target="_blank" rel="noreferrer">894. 所有可能的满二叉树</a> ,对于这个题，直接 BFS 就好了。由于这种题很少，因此不做多的介绍。大家只要把最核心的掌握了，这种东西自然水到渠成。</p><h4 id="二叉搜索树的构建" tabindex="-1">二叉搜索树的构建 <a class="header-anchor" href="#二叉搜索树的构建" aria-label="Permalink to &quot;二叉搜索树的构建&quot;">​</a></h4><p>普通二叉树无法根据一种序列重构的原因是只知道根节点，无法区分左右子树。如果是二叉搜索树，那么就有可能根据<strong>一种遍历序列</strong>构造出来。 原因就在于二叉搜索树的根节点的值大于所有的左子树的值，且小于所有的右子树的值。因此我们可以根据这一特性去确定左右子树的位置，经过这样的转换就和上面的普通二叉树没有啥区别了。比如 <a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noreferrer">1008. 前序遍历构造二叉搜索树</a></p><h3 id="修改类" tabindex="-1">修改类 <a class="header-anchor" href="#修改类" aria-label="Permalink to &quot;修改类&quot;">​</a></h3><p>上面介绍了两种常见的题型：搜索类和构建类。还有一种比例相对比较小的题目类型是修改类。</p><blockquote><p>当然修改类的题目也是要基于搜索算法的，不找到目标怎么删呢？</p></blockquote><p>修改类的题目有两种基本类型。</p><h4 id="题目要求的修改" tabindex="-1">题目要求的修改 <a class="header-anchor" href="#题目要求的修改" aria-label="Permalink to &quot;题目要求的修改&quot;">​</a></h4><p>一种是题目让你增加，删除节点，或者是修改节点的值或者指向。</p><p>修改指针的题目一般不难，比如 <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noreferrer">116. 填充每个节点的下一个右侧节点指针</a>，这不就是 BFS 的时候顺便记录一下上一次访问的同层节点，然后增加一个指针不就行了么？关于 BFS ，套用我的<strong>带层的 BFS 模板</strong>就搞定了。</p><p>增加和删除的题目一般稍微复杂，比如 <a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noreferrer">450. 删除二叉搜索树中的节点</a> 和 <a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noreferrer">669. 修剪二叉搜索树</a>。西法我教你两个套路，面对这种问题就不带怕的。那就是<strong>后序遍历 + 虚拟节点</strong>，这两个技巧同样放在后面的七个技巧部分讲解。是不是对七个技巧很期待？^_^</p><blockquote><p>实际工程中，我们也可以不删除节点，而是给节点做一个标记，表示已经被删除了，这叫做软删除。</p></blockquote><h4 id="算法需要-自己修改" tabindex="-1">算法需要，自己修改 <a class="header-anchor" href="#算法需要-自己修改" aria-label="Permalink to &quot;算法需要，自己修改&quot;">​</a></h4><p>另外一种是为了方便计算，自己加了一个指针。</p><p>比如 <a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noreferrer">863. 二叉树中所有距离为 K 的结点</a> 通过修改树的节点类，增加一个指向父节点的引用 parent，问题就转化为距离目标节点一定距离的问题了，此时可是用我上面讲的<strong>带层的 BFS 模板</strong>解决。</p><p>动态语言可以直接加属性（比如上面的 parent），而静态语言是不允许的，因此你需要增加一个新的类定义。不过你也可以使用字典来实现， key 是 node 引用， value 是你想记录的东西，比如这里的 parent 节点。</p><p>比如对于 Java 来说，我们可以：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; parent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(TreeNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TreeNode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, parent);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.left, node);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node.right, node);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>简单回顾一下这一小节的知识。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/a6ab433962240184d857f1fe1e6cbdf4.jpg" alt=""></p><p>接下来是做树的题目不得不知的四个重要概念。</p><h2 id="四个重要概念" tabindex="-1">四个重要概念 <a class="header-anchor" href="#四个重要概念" aria-label="Permalink to &quot;四个重要概念&quot;">​</a></h2><h3 id="二叉搜索树" tabindex="-1">二叉搜索树 <a class="header-anchor" href="#二叉搜索树" aria-label="Permalink to &quot;二叉搜索树&quot;">​</a></h3><p>二叉搜索树（Binary Search Tree），亦称二叉查找树。</p><p>二叉搜索树具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p>对于一个二叉查找树，常规操作有<code>插入，查找，删除，找父节点，求最大值，求最小值。</code></p><h4 id="天生适合查找" tabindex="-1">天生适合查找 <a class="header-anchor" href="#天生适合查找" aria-label="Permalink to &quot;天生适合查找&quot;">​</a></h4><p>二叉查找树，之所以叫查找树就是因为其非常适合查找。</p><p>举个例子，如下一颗二叉查找树，我们想找节点值小于且最接近 58 的节点，搜索的流程如图所示：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/ea842edbd0162f0117a30aa6fb800936.jpg" alt="bst"> （图片来自 <a href="https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/%EF%BC%89" target="_blank" rel="noreferrer">https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/）</a></p><p>可以看出每次向下走，都会排除了一个分支，如果一颗二叉搜索树同时也是一颗二叉平衡树的话，那么其搜索过程时间复杂度就是 <mjx-container class="MathJax" jax="SVG" style="direction:ltr;position:relative;"><svg style="overflow:visible;min-height:1px;min-width:1px;vertical-align:-0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.346ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3689 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(3300,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top:0px;left:0px;clip:rect(1px, 1px, 1px, 1px);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;padding:1px 0px 0px 0px;border:0px;display:block;width:auto;overflow:hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>。实际上，<strong>平衡二叉搜索树的查找和有序数组的二分查找本质都是一样的，只是数据的存储方式不同罢了</strong>。那为什么有了有序数组二分，还需要二叉搜索树呢？原因在于树的结构对于动态数据比较友好，比如数据是频繁变动的，比如经常添加和删除，那么就可以使用二叉搜索树。理论上添加和删除的时间复杂度都是 <mjx-container class="MathJax" jax="SVG" style="direction:ltr;position:relative;"><svg style="overflow:visible;min-height:1px;min-width:1px;vertical-align:-0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.79ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2117 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(1728,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top:0px;left:0px;clip:rect(1px, 1px, 1px, 1px);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;padding:1px 0px 0px 0px;border:0px;display:block;width:auto;overflow:hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>，其中 h 为树的高度，如果是一颗平衡二叉搜索树，那么时间复杂度就是 <mjx-container class="MathJax" jax="SVG" style="direction:ltr;position:relative;"><svg style="overflow:visible;min-height:1px;min-width:1px;vertical-align:-0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.346ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3689 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(3300,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top:0px;left:0px;clip:rect(1px, 1px, 1px, 1px);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;padding:1px 0px 0px 0px;border:0px;display:block;width:auto;overflow:hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>。而数组的添加和删除的时间复杂度为 <mjx-container class="MathJax" jax="SVG" style="direction:ltr;position:relative;"><svg style="overflow:visible;min-height:1px;min-width:1px;vertical-align:-0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2429 1000" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top:0px;left:0px;clip:rect(1px, 1px, 1px, 1px);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;padding:1px 0px 0px 0px;border:0px;display:block;width:auto;overflow:hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>，其中 N 为数组长度。</p><p><strong>方便搜索，是二叉搜索树核心的设计初衷。不让查找算法时间复杂度退化到线性是平衡二叉树的初衷</strong>。</p><p>我们平时说的二分很多是数组的二分，因为数组可以随机访问嘛。不过这种二分实在太狭义了，二分的本质是将问题规模缩小到一半，因此二分和数据结构没有本质关系，但是不同的数据结构却给二分赋予了不同的色彩。比如跳表就是链表的二分，二叉搜索树就是树的二分等。随着大家对算法和数据结构的了解的加深，会发现更多有意思的东西^_^</p><h4 id="中序遍历是有序的" tabindex="-1">中序遍历是有序的 <a class="header-anchor" href="#中序遍历是有序的" aria-label="Permalink to &quot;中序遍历是有序的&quot;">​</a></h4><p>另外二叉查找树有一个性质，这个性质对于做题很多帮助，那就是： <strong>二叉搜索树的中序遍历的结果是一个有序数组</strong>。 比如 <a href="./../0098.validate-binary-search-tree.html">98. 验证二叉搜索树</a> 就可以直接中序遍历，并<strong>一边遍历一边判断遍历结果是否是单调递增的</strong>，如果不是则提前返回 False 即可。</p><p>再比如 <a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noreferrer">99. 恢复二叉搜索树</a>，官方难度为困难。题目大意是<code>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</code> 我们可以先中序遍历发现不是递增的节点，他们就是被错误交换的节点，然后交换恢复即可。这道题难点就在于一点，即错误交换可能错误交换了中序遍历的相邻节点或者中序遍历的非相邻节点，这是两种 case，需要分别讨论。</p><p>类似的题目很多，不再赘述。练习的话大家可以做一下这几道题。</p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noreferrer">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noreferrer">98. 验证二叉搜索树</a></li><li><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noreferrer">173. 二叉搜索树迭代器</a></li><li><a href="https://leetcode-cn.com/problems/count-univalue-subtrees/" target="_blank" rel="noreferrer">250. 统计同值子树</a></li></ul><p>大家如果<strong>碰到二叉搜索树的搜索类题目，一定先想下能不能利用这个性质来做。</strong></p><h3 id="完全二叉树" tabindex="-1">完全二叉树 <a class="header-anchor" href="#完全二叉树" aria-label="Permalink to &quot;完全二叉树&quot;">​</a></h3><p>一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><p>如下就是一颗完全二叉树：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/dce73f5156eb6fb0a627dbf1a903e90c.jpg" alt=""></p><p>直接考察完全二叉树的题目虽然不多，貌似只有一道 <a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noreferrer">222. 完全二叉树的节点个数</a>（二分可解），但是理解完全二叉树对你做题其实帮助很大。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/2b87388c0760364901dac6f77c336cfb.jpg" alt=""></p><p>如上图，是一颗普通的二叉树。如果我将其中的空节点补充完全，那么它就是一颗完全二叉树了。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/5a91963d80cad08a958d04861513ff16.jpg" alt=""></p><p>这有什么用呢？这很有用！我总结了两个用处：</p><ol><li>我们可以给完全二叉树编号，这样父子之间就可以通过编号轻松求出。比如我给所有节点从左到右从上到下依次从 1 开始编号。那么已知一个节点的编号是 i，那么其左子节点就是 2 _ i，右子节点就是 2 _ 1 + 1，父节点就是 (i + 1) / 2。</li></ol><p>熟悉二叉堆的同学可能发现了，这就是用数组实现的二叉堆，其实<strong>二叉堆就是完全二叉树的一个应用</strong>。</p><p>有的同学会说，”但是很多题目都不是完全二叉树呀，那不是用不上了么？“其实不然，我们只要想象它存在即可，我们将空节点脑补上去不就可以了？比如 <a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noreferrer">662. 二叉树最大宽度</a>。题目描述：</p><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的 null 节点也计入长度）之间的长度。</p><p>示例 1:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>           1</span></span>
<span class="line"><span>         /   \</span></span>
<span class="line"><span>        3     2</span></span>
<span class="line"><span>       / \     \</span></span>
<span class="line"><span>      5   3     9</span></span>
<span class="line"><span></span></span>
<span class="line"><span>输出: 4</span></span>
<span class="line"><span>解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>很简单，一个带层的 BFS 模板即可搞定，简直就是默写题。不过这里需要注意两点：</p><ul><li>入队的时候除了要将普通节点入队，还要空节点入队。</li><li>出队的时候除了入队节点本身，还要将节点的位置信息入队，即下方代码的 pos。</li></ul><p>参考代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Definition for a binary tree node.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># class TreeNode:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#     def __init__(self, x):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#         self.val = x</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#         self.left = None</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#         self.right = None</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> widthOfBinaryTree</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.deque([(root, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        steps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cur_depth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> leftmost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(q)):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                node, pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q.popleft()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # 节点编号关关系是不是用上了？</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    q.append((node.left, pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    q.append((node.right, pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # 逻辑开始</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur_depth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> steps:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        cur_depth </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> steps</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        leftmost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pos</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ans, pos </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> leftmost </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    # 逻辑结束</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            steps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>再比如<a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noreferrer">剑指 Offer 37. 序列化二叉树</a>。如果我将一个二叉树的完全二叉树形式序列化，然后通过 BFS 反序列化，这不就是力扣官方序列化树的方式么？比如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    1</span></span>
<span class="line"><span>   / \</span></span>
<span class="line"><span>  2   3</span></span>
<span class="line"><span>     / \</span></span>
<span class="line"><span>    4   5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>序列化为 &quot;[1,2,3,null,null,4,5]&quot;。 这不就是我刚刚画的完全二叉树么？就是将一个普通的二叉树硬生生当成完全二叉树用了。</p><blockquote><p>其实这并不是序列化成了完全二叉树，下面会纠正。</p></blockquote><p>将一颗普通树序列化为完全二叉树很简单，只要将空节点当成普通节点入队处理即可。代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Codec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> serialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root):</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.deque([root])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q.popleft()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cur.val) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;,&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                q.append(cur.left)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                q.append(cur.right)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                # 除了这里不一样，其他和普通的不记录层的 BFS 没区别</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null,&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 末尾会多一个逗号，我们去掉它。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ans[:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>细心的同学可能会发现，我上面的代码其实并不是将树序列化成了完全二叉树，这个我们稍后就会讲到。另外后面多余的空节点也一并序列化了。这其实是可以优化的，优化的方式也很简单，那就是去除末尾的 null 即可。</p><p>你只要彻底理解我刚才讲的<code>我们可以给完全二叉树编号，这样父子之间就可以通过编号轻松求出。比如我给所有节点从左到右从上到下依次从 1 开始编号。那么已知一个节点的编号是 i，那么其左子节点就是 2 * i，右子节点就是 2 * i + 1，父节点就是 i / 2。</code> 这句话，那么反序列化对你就不是难事。</p><p>如果我用一个箭头表示节点的父子关系，箭头指向节点的两个子节点，那么大概是这样的：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/cca9b3a5288b35d20ce23db29c545b1e.jpg" alt=""></p><p>我们刚才提到了：</p><ul><li>1 号节点的两个子节点的 2 号 和 3 号。</li><li>2 号节点的两个子节点的 4 号 和 5 号。</li><li>...</li><li>i 号节点的两个子节点的 <code>2 * i</code> 号 和 <code>2 * i + 1</code> 号。</li></ul><p>此时你可能会写出类似这样的代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deserialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, data):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.split(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;,&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(nodes[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 从一号开始编号，编号信息一起入队</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.deque([(root, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cur, i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q.popleft()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 2 * i 是左节点，而 2 * i 编号对应的其实是索引为 2 * i - 1 的元素， 右节点同理。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes): lv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes): rv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(lv)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 将左节点和 它的编号 2 * i 入队</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            q.append((l, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(rv)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 将右节点和 它的编号 2 * i + 1 入队</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            q.append((r, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>但是上面的代码是不对的，因为我们序列化的时候其实不是完全二叉树，这也是上面我埋下的伏笔。因此遇到类似这样的 case 就会挂：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/4412d3c58faa6d80973b720f27fe733b.jpg" alt=""></p><p>这也是我前面说”上面代码的序列化并不是一颗完全二叉树“的原因。</p><p>其实这个很好解决， 核心还是上面我画的那种图：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/cca9b3a5288b35d20ce23db29c545b1e.jpg" alt=""></p><p>其实我们可以：</p><ul><li>用三个指针分别指向数组第一项，第二项和第三项（如果存在的话），这里用 p1，p2，p3 来标记，分别表示当前处理的节点，当前处理的节点的左子节点和当前处理的节点的右子节点。</li><li>p1 每次移动一位，p2 和 p3 每次移动两位。</li><li>p1.left = p2; p1.right = p3。</li><li>持续上面的步骤直到 p1 移动到最后。</li></ul><p>因此代码就不难写出了。反序列化代码如下：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deserialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, data):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    nodes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data.split(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;,&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(nodes[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> collections.deque([root])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nodes) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> q.popleft()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        rv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nodes[i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(lv)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            q.append(l)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;null&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(rv)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            q.append(r)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cur.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这个题目虽然并不是完全二叉树的题目，但是却和完全二叉树很像，有借鉴完全二叉树的地方。</p><h3 id="路径" tabindex="-1">路径 <a class="header-anchor" href="#路径" aria-label="Permalink to &quot;路径&quot;">​</a></h3><p>关于路径这个概念，leetcode 真的挺喜欢考察的，不信你自己去 leetcode 官网搜索一下路径，看有多少题。树的路径这种题目的变种很多，算是一种经典的考点了。</p><p>要明白路径的概念，以及如何解决这种题，只需要看一个题目就好了 <a href="./../0124.binary-tree-maximum-path-sum.html">124.二叉树中的最大路径和</a>，虽然是困难难度，但是搞清楚概念的话，和简单难度没啥区别。 接下来，我们就以这道题讲解一下。</p><p>这道题的题目是 <code>给定一个非空二叉树，返回其最大路径和</code>。路径的概念是：<code>一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</code>这听起来真的不容易理解，力扣给的 demo 我也没搞懂，这里我自己画了几个图来给大家解释一下这个概念。</p><p>首先是官网给的两个例子：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/c69acc9c03dff04246eaa8d61692c904.jpg" alt=""></p><p>接着是我自己画的一个例子：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/e5311307c613985aab01310ab701cd82.jpg" alt=""></p><p>如图红色的部分是最大路径上的节点。</p><p>可以看出：</p><ul><li>路径可以由一个节点做成，可以由两个节点组成，也可以由三个节点组成等等，但是必须连续。</li><li>路径必须是”直来直去“的，不能有分叉。 比如上图的路径的左下角是 3，当然也可以是 2，但是 2 比较小。但是不可以 2 和 3 同时选。</li></ul><p>我们继续回到 124 题。题目说是 ”从任意节点出发.......“ 看完这个描述我会想到大概率是要么全局记录最大值，要么双递归。</p><ul><li>如果使用双递归，那么复杂度就是 <mjx-container class="MathJax" jax="SVG" style="direction:ltr;position:relative;"><svg style="overflow:visible;min-height:1px;min-width:1px;vertical-align:-0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.606ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2919.8 1083.9" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z" style="stroke-width:3;"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z" style="stroke-width:3;"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z" style="stroke-width:3;"></path></g><g data-mml-node="mn" transform="translate(975.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" style="stroke-width:3;"></path></g></g><g data-mml-node="mo" transform="translate(2530.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z" style="stroke-width:3;"></path></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline" style="top:0px;left:0px;clip:rect(1px, 1px, 1px, 1px);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;padding:1px 0px 0px 0px;border:0px;display:block;width:auto;overflow:hidden;"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>，实际上，子树的路径和计算出来了，可以推导出父节点的最大路径和，因此如果使用双递归会有重复计算。一个可行的方式是记忆化递归。</li><li>如果使用全局记录最大值，只需要在递归的时候 return 当前的一条边（上面提了不能拐），并在函数内部计算以当前节点出发的最大路径和，并更新全局最大值即可。 这里的核心其实是 return 较大的一条边，因为较小的边不可能是答案。</li></ul><p>这里我选择使用第二种方法。</p><p>代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-inf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxPathSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.left)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.right)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 选择当前的节点，并选择左右两边，当然左右两边也可以不选。必要时更新全局最大值</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ans, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(l,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(r, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.val)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 只返回一边，因此我们挑大的返回。当然左右两边也可以不选</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(l, r, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.val</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dfs(root)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ans</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>类似题目 <a href="./../0113.path-sum-ii.html">113. 路径总和 I</a></p></blockquote><h3 id="距离" tabindex="-1">距离 <a class="header-anchor" href="#距离" aria-label="Permalink to &quot;距离&quot;">​</a></h3><p>和路径类似，距离也是一个相似且频繁出现的一个考点，并且二者都是搜索类题目的考点。原因就在于最短路径就是距离，而树的最短路径就是边的数目。</p><p>这两个题练习一下，碰到距离的题目基本就稳了。</p><ul><li><a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/description/" target="_blank" rel="noreferrer">834.树中距离之和</a></li><li><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/description/" target="_blank" rel="noreferrer">863.二叉树中所有距离为 K 的结点</a></li></ul><h2 id="七个技巧" tabindex="-1">七个技巧 <a class="header-anchor" href="#七个技巧" aria-label="Permalink to &quot;七个技巧&quot;">​</a></h2><p>上面数次提到了七个技巧，相信大家已经迫不及待想要看看这七个技巧了吧。那就让我拿出本章压箱底的内容吧~</p><blockquote><p>注意，这七个技巧全部是基于 dfs 的，bfs 掌握了模板就行，基本没有什么技巧可言。</p></blockquote><p>认真学习的小伙伴可以发现了， 上面的内容只有<strong>二叉树的迭代写法（双色标记法）</strong> 和 <strong>两个 BFS 模板</strong> 具有实操性，其他大多是战略思想上的。算法思想固然重要，但是要结合具体实践落地才能有实践价值，才能让我们把知识消化成自己的。而这一节满满的全是实用干货ヽ(￣ ω ￣(￣ ω ￣〃)ゝ。</p><h3 id="dfs-root" tabindex="-1">dfs(root) <a class="header-anchor" href="#dfs-root" aria-label="Permalink to &quot;dfs(root)&quot;">​</a></h3><p>第一个技巧，也是最容易掌握的一个技巧。我们写力扣的树题目的时候，函数的入参全都是叫 root。而这个技巧是说，我们在写 dfs 函数的时候，要将函数中表示当前节点的形参<strong>也</strong>写成 root。即：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # your code</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而之前我一直习惯写成 node，即：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # your code</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可能有的同学想问：” 这有什么关系么？“。我总结了两个原因。</p><p>第一个原因是：以前 dfs 的形参写的是 node， 而我经常误写成 root，导致出错（这个错误并不会抛错，因此不是特别容易发现）。自从换成了 root 就没有发生这样的问题了。</p><p>第二个原因是：这样写相当于把 root 当成是 current 指针来用了。最开始 current 指针指向 root，然后不断修改指向树的其它节点。这样就概念就简化了，只有一个当前指针的概念。如果使用 node，就是当前指针 + root 指针两个概念了。</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/f03f2746468c923aab7386b3806e1b35.jpg" alt=""></p><p>（一开始 current 就是 root）</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/4318f3d9cf6605ff326ef4cbb215f099.jpg" alt=""></p><p>（后面 current 不断改变。具体如何改变，取决于你的搜索算法，是 dfs 还是 bfs 等）</p><h3 id="单-双递归" tabindex="-1">单/双递归 <a class="header-anchor" href="#单-双递归" aria-label="Permalink to &quot;单/双递归&quot;">​</a></h3><p>上面的技巧稍显简单，但是却有用。这里介绍一个稍微难一点的技巧，也更加有用。</p><p>我们知道递归是一个很有用的编程技巧，灵活使用递归，可以使自己的代码更加简洁，简洁意味着代码不容易出错，即使出错了，也能及时发现问题并修复。</p><p>树的题目大多数都可以用递归轻松地解决。<strong>如果一个递归不行，那么来两个。（至今没见过三递归或更多递归）</strong></p><p>单递归大家写的比较多了，其实本篇文章的大部分递归都是单递归。 那什么时候需要两个递归呢？其实我上面已经提到了，那就是<strong>如果题目有类似，任意节点开始 xxxx 或者所有 xxx</strong>这样的说法，就可以考虑使用双递归。但是如果递归中有重复计算，则可以使用双递归 + 记忆化 或者直接单递归。</p><p>比如 <a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noreferrer">面试题 04.12. 求和路径</a>，再比如 <a href="https://leetcode-cn.com/problems/binary-tree-tilt/description/" target="_blank" rel="noreferrer">563.二叉树的坡度</a> 这两道题的题目说法都可以考虑使用双递归求解。</p><p>双递归的基本套路就是一个主递归函数和一个内部递归函数。主递归函数负责计算以某一个节点开始的 xxxx，内部递归函数负责计算 xxxx，这样就实现了以<strong>所有节点开始的 xxxx</strong>。</p><blockquote><p>其中 xxx 可以替换成任何题目描述，比如路径和等</p></blockquote><p>一个典型的加法双递归是这样的：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs_inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 这里写你的逻辑，就是前序遍历</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs_inner(root.left)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs_inner(root.right)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 或者在这里写你的逻辑，那就是后序遍历</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs_main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs_inner(root) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs_main(root.left) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs_main(root.right)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>大家可以用我的模板去套一下上面两道题试试。</p><h3 id="前后遍历" tabindex="-1">前后遍历 <a class="header-anchor" href="#前后遍历" aria-label="Permalink to &quot;前后遍历&quot;">​</a></h3><p>前面我的链表专题也提到了前后序遍历。由于链表只有一个 next 指针，因此只有两种遍历。而二叉树有两个指针，因此常见的遍历有三个，除了前后序，还有一个中序。而中序除了二叉搜索树，其他地方用的并不多。</p><p>和链表一样， 要掌握树的前后序，也只需要记住一句话就好了。那就是<strong>如果是前序遍历，那么你可以想象上面的节点都处理好了，怎么处理的不用管</strong>。相应地<strong>如果是后序遍历，那么你可以想象下面的树都处理好了，怎么处理的不用管</strong>。这句话的正确性也是毋庸置疑。</p><p>前后序对链表来说比较直观。对于树来说，其实更形象地说应该是自顶向下或者自底向上。自顶向下和自底向上在算法上是不同的，不同的写法有时候对应不同的书写难度。比如 <a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noreferrer">sum-root-to-leaf-numbers</a>，这种题目就适合通过参数扩展 + 前序来完成。</p><blockquote><p>关于参数扩展的技巧，我们在后面展开。</p></blockquote><ul><li><p><strong>自顶向下</strong>就是在每个递归层级，首先访问节点来计算一些值，并在递归调用函数时将这些值传递到子节点，一般是<strong>通过参数传到子树</strong>中。</p></li><li><p><strong>自底向上</strong>是另一种常见的递归方法，首先对所有子节点递归地调用函数，然后根据<strong>返回值</strong>和<strong>根节点本身</strong>的值得到答案。</p></li></ul><p>关于前后序的思维技巧，可以参考我的<a href="./linked-list.html">这个文章</a> 的<strong>前后序部分</strong>。</p><p>总结下我的经验：</p><ul><li>大多数树的题使用后序遍历比较简单，并且大多需要依赖左右子树的返回值。比如 <a href="https://leetcode-cn.com/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noreferrer">1448. 统计二叉树中好节点的数目</a></li><li>不多的问题需要前序遍历，而前序遍历通常要结合参数扩展技巧。比如 <a href="https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/" target="_blank" rel="noreferrer">1022. 从根到叶的二进制数之和</a></li><li>如果你能使用参数和节点本身的值来决定什么应该是传递给它子节点的参数，那就用前序遍历。</li><li>如果对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出当前节点的答案，那就用后序遍历。</li><li>如果遇到二叉搜索树则考虑中序遍历</li></ul><h3 id="虚拟节点" tabindex="-1">虚拟节点 <a class="header-anchor" href="#虚拟节点" aria-label="Permalink to &quot;虚拟节点&quot;">​</a></h3><p>是的！不仅仅链表有虚拟节点的技巧，树也是一样。关于这点大家可能比较容易忽视。</p><p>回忆一下链表的虚拟指针的技巧，我们通常在什么时候才会使用？</p><ul><li>其中一种情况是<code>链表的头会被修改</code>。这个时候通常需要一个虚拟指针来做新的头指针，这样就不需要考虑第一个指针的问题了（因为此时第一个指针变成了我们的虚拟指针，而虚拟指针是不用参与题目运算的）。树也是一样，当你需要对树的头节点（在树中我们称之为根节点）进行修改的时候， 就可以考虑使用虚拟指针的技巧了。</li><li>另外一种是题目需要返回树中间的某个节点（不是返回根节点）。实际上也可借助虚拟节点。由于我上面提到的指针的操作，实际上，你可以新建一个虚拟头，然后让虚拟头在恰当的时候（刚好指向需要返回的节点）断开连接，这样我们就可以返回虚拟头的 next 就 ok 了。</li></ul><p>更多关于虚拟指针的技巧可以参考<a href="./linked-list.html">这个文章</a> 的<strong>虚拟头部分</strong>。</p><p>下面就力扣中的两道题来看一下。</p><h4 id="【题目一】814-二叉树剪枝" tabindex="-1">【题目一】814. 二叉树剪枝 <a class="header-anchor" href="#【题目一】814-二叉树剪枝" aria-label="Permalink to &quot;【题目一】814. 二叉树剪枝&quot;">​</a></h4><p><a href="./../0814.html">814. 二叉树剪枝</a></p><h4 id="【题目二】1325-删除给定值的叶子节点" tabindex="-1">【题目二】1325. 删除给定值的叶子节点 <a class="header-anchor" href="#【题目二】1325-删除给定值的叶子节点" aria-label="Permalink to &quot;【题目二】1325. 删除给定值的叶子节点&quot;">​</a></h4><p><a href="./../1325.html">1325. 删除给定值的叶子节点</a></p><h3 id="边界" tabindex="-1">边界 <a class="header-anchor" href="#边界" aria-label="Permalink to &quot;边界&quot;">​</a></h3><p>发现自己老是边界考虑不到，首先要知道这是正常的，人类的本能。 大家要克服这种本能， 只有多做，慢慢就能克服。 就像改一个坏习惯一样，除了坚持，一个有用的技巧是奖励和惩罚，我也用过这个技巧。</p><p>上面我介绍了树的三种题型。对于不同的题型其实边界考虑的侧重点也是不一样的，下面我们展开聊聊。</p><h4 id="搜索类-1" tabindex="-1">搜索类 <a class="header-anchor" href="#搜索类-1" aria-label="Permalink to &quot;搜索类&quot;">​</a></h4><p>搜索类的题目，树的边界其实比较简单。 90% 以上的题目边界就两种情况。</p><blockquote><p>树的题目绝大多树又是搜索类，你想想掌握这两种情况多重要。</p></blockquote><ol><li>空节点</li></ol><p>伪代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;是空节点，你需要返回合适的值&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # your code here`</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="2"><li>叶子节点</li></ol><p>伪代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;是空节点，你需要返回合适的值&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.right: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;是叶子节点，你需要返回合适的值&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># your code here`</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>一张图总结一下：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/aee0d2cd4cdc9c2790f4996f12734f4c.jpg" alt=""></p><p>经过这样的处理，后面的代码基本都不需要判空了。</p><h4 id="构建类-1" tabindex="-1">构建类 <a class="header-anchor" href="#构建类-1" aria-label="Permalink to &quot;构建类&quot;">​</a></h4><p>相比于搜索类， 构建就比较麻烦了。我总结了两个常见的边界。</p><ol><li>参数扩展的边界</li></ol><p>比如 1008 题， 根据前序遍历构造二叉搜索树。我就少考虑的边界。</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bstFromPreorder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, preorder: List[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) -&gt; TreeNode:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(start, end):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(preorder[start])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(preorder[start])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, end </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> preorder[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> preorder[start]:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, end)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mid </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            root.right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(mid, end)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">len</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(preorder) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>注意上面的代码没有判断 start == end 的情况，加下面这个判断就好了。</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TreeNode(preorder[start])</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li>虚拟节点</li></ol><p>除了搜索类的技巧可以用于构建类外，也可以考虑用我上面的讲的虚拟节点。</p><h3 id="参数扩展大法" tabindex="-1">参数扩展大法 <a class="header-anchor" href="#参数扩展大法" aria-label="Permalink to &quot;参数扩展大法&quot;">​</a></h3><p>参数扩展这个技巧非常好用，一旦掌握你会爱不释手。</p><p>如果不考虑参数扩展， 一个最简单的 dfs 通常是下面这样：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # do something</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而有时候，我们需要 dfs 携带更多的有用信息。典型的有以下三种情况：</p><ol><li>携带父亲或者爷爷的信息。</li></ol><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, parent):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.left, root)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.right, root)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="2"><li>携带路径信息，可以是路径和或者具体的路径数组等。</li></ol><p>路径和：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, path_sum):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 这里可以拿到根到叶子的路径和</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path_sum</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.left, path_sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.val)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.right, path_sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.val)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>路径：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, path):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 这里可以拿到根到叶子的路径</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path.append(root.val)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.left, path)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dfs(root.right, path)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 撤销</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path.pop()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>学会了这个技巧，大家可以用 <a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noreferrer">面试题 04.12. 求和路径</a> 来练练手。</p><p>以上几个模板都很常见，类似的场景还有很多。总之当你需要传递额外信息给子节点（关键字是子节点）的时候，请务必掌握这种技巧。这也解释了为啥参数扩展经常用于前序遍历。</p><ol start="3"><li>二叉搜索树的搜索题大多数都需要扩展参考，甚至怎么扩展都是固定的。</li></ol><p>二叉搜索树的搜索总是将最大值和最小值通过参数传递到左右子树，类似 <code>dfs(root, lower, upper)</code>，然后在递归过程更新最大和最小值即可。这里需要注意的是 (lower, upper) 是的一个左右都开放的区间。</p><p>比如有一个题<a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noreferrer">783. 二叉搜索树节点最小距离</a>是求二叉搜索树的最小差值的绝对值。当然这道题也可以用我们前面提到的<strong>二叉搜索树的中序遍历的结果是一个有序数组</strong>这个性质来做。只需要一次遍历，最小差一定出现在相邻的两个节点之间。</p><p>这里我用另外一种方法，该方法就是扩展参数大法中的 左右边界法。</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> minDiffInBST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, lower, upper):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> upper </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lower</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.left, lower, node.val)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        right </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.right, node.val, upper)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 要么在左，要么在右，不可能横跨（因为是 BST）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(left, right)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(root, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-inf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;inf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其实这个技巧不仅适用二叉搜索树，也可是适用在别的树，比如 <a href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noreferrer">1026. 节点与其祖先之间的最大差值</a>,题目大意是：给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。</p><p>使用类似上面的套路轻松求解。</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> maxAncestorDiff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, lower, upper):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> upper </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lower</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 要么在左，要么在右，要么横跨。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dfs(root.left, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.val, lower), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.val, upper)), dfs(root.right, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">min</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.val, lower), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root.val, upper)))</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(root, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;inf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-inf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="返回元组-列表" tabindex="-1">返回元组/列表 <a class="header-anchor" href="#返回元组-列表" aria-label="Permalink to &quot;返回元组/列表&quot;">​</a></h3><p>通常，我们的 dfs 函数的返回值是一个单值。而有时候为了方便计算，我们会返回一个数组或者元祖。</p><blockquote><p>对于个数固定情况，我们一般使用元组，当然返回数组也是一样的。</p></blockquote><p><strong>这个技巧和参数扩展有异曲同工之妙，只不过一个作用于函数参数，一个作用于函数返回值。</strong></p><h4 id="返回元祖" tabindex="-1">返回元祖 <a class="header-anchor" href="#返回元祖" aria-label="Permalink to &quot;返回元祖&quot;">​</a></h4><p>返回元组的情况还算比较常见。比如 <a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank" rel="noreferrer">865. 具有所有最深节点的最小子树</a>，一个简单的想法是 dfs 返回深度，我们通过比较左右子树的深度来定位答案（最深的节点位置）。</p><p>代码：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subtreeWithAllDeepest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, d):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            l_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.left, d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            r_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.right, d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r_d: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l_d</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r_d</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(root, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是题目要求返回的是树节点的引用啊，这个时候应该考虑返回元祖，即<strong>除了返回深度，也要把节点给返回</strong>。</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subtreeWithAllDeepest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode) -&gt; TreeNode:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node, d):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node, d)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            l, l_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.left, d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            r, r_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(node.right, d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r_d: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (node, l_d)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r_d: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (l, l_d)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (r, r_d)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(root, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h4 id="返回数组" tabindex="-1">返回数组 <a class="header-anchor" href="#返回数组" aria-label="Permalink to &quot;返回数组&quot;">​</a></h4><p>dfs 返回数组比较少见。即使题目要求返回数组，我们也通常是声明一个数组，在 dfs 过程不断 push，最终返回这个数组。而不会选择返回一个数组。绝大多数情况下，返回数组是用于计算笛卡尔积。因此你需要用到笛卡尔积的时候，考虑使用返回数组的方式。</p><blockquote><p>一般来说，如果需要使用笛卡尔积的情况还是比较容易看出的。另外一个不太准确的技巧是，如果题目有”所有可能“，”所有情况“，可以考虑使用此技巧。</p></blockquote><p>一个典型的题目是 <a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/description/" target="_blank" rel="noreferrer">1530.好叶子节点对的数量</a></p><p>题目描述：</p><p>给你二叉树的根节点 root 和一个整数 distance 。</p><p>如果二叉树中两个叶节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。</p><p>返回树中 好叶子节点对的数量 。</p><p>示例 1：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/6fdedcd9d0e00ce0ac5071644253d72c.jpg" alt=""></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：root = [1,2,3,null,4], distance = 3</span></span>
<span class="line"><span>输出：1</span></span>
<span class="line"><span>解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>示例 2：</p><p><img src="https://imgs-1251264059.cos.ap-chengdu.myqcloud.com/picgo-v2/06efd83566cf0e3025ccdd2be69f3aff.jpg" alt=""></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：root = [1,2,3,4,5,6,7], distance = 3</span></span>
<span class="line"><span>输出：2</span></span>
<span class="line"><span>解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>示例 3：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3</span></span>
<span class="line"><span>输出：1</span></span>
<span class="line"><span>解释：唯一的好叶子节点对是 [2,5] 。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>示例 4：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：root = [100], distance = 1</span></span>
<span class="line"><span>输出：0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>示例 5：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>输入：root = [1,1,1], distance = 2</span></span>
<span class="line"><span>输出：1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>提示：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>tree 的节点数在 [1, 2^10] 范围内。</span></span>
<span class="line"><span>每个节点的值都在 [1, 100] 之间。</span></span>
<span class="line"><span>1 &lt;= distance &lt;= 10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面我们学习了路径的概念，在这道题又用上了。</p><p>其实两个叶子节点的最短路径（距离）可以用其最近的公共祖先来辅助计算。即<code>两个叶子节点的最短路径 = 其中一个叶子节点到最近公共祖先的距离 + 另外一个叶子节点到最近公共祖先的距离</code>。</p><p>因此我们可以定义 dfs(root)，其功能是计算以 root 作为出发点，到其各个叶子节点的距离。 如果其子节点有 8 个叶子节点，那么就返回一个长度为 8 的数组， 数组每一项的值就是其到对应叶子节点的距离。</p><p>如果子树的结果计算出来了，那么父节点只需要把子树的每一项加 1 即可。这点不难理解，因为<strong>父到各个叶子节点的距离就是父节点到子节点的距离（1） + 子节点到各个叶子节点的距离</strong>。</p><p>由上面的推导可知需要先计算子树的信息，因此我们选择前序遍历。</p><p>完整代码（Python）：</p><div class="language-py vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> countPairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, root: TreeNode, distance: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dfs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root.right:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ls </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(root.left)]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            rs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dfs(root.right)]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 笛卡尔积</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ls:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rs:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> distance:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ans </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ls </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        dfs(root)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.ans</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><a href="https://leetcode-cn.com/problems/all-possible-full-binary-trees/description/" target="_blank" rel="noreferrer">894. 所有可能的满二叉树</a> 也是一样的套路，大家用上面的知识练下手吧~</p><h2 id="经典题目" tabindex="-1">经典题目 <a class="header-anchor" href="#经典题目" aria-label="Permalink to &quot;经典题目&quot;">​</a></h2><p>推荐大家先把本文提到的题目都做一遍，然后用本文学到的知识做一下下面十道练习题，检验一下自己的学习成果吧！</p><ul><li><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noreferrer">剑指 Offer 55 - I. 二叉树的深度</a></li><li><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noreferrer">剑指 Offer 34. 二叉树中和为某一值的路径</a></li><li><a href="./../0101.symmetric-tree.html">101. 对称二叉树</a></li><li><a href="./../0226.invert-binary-tree.html">226. 翻转二叉树</a></li><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noreferrer">543. 二叉树的直径</a></li><li><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noreferrer">662. 二叉树最大宽度</a></li><li><a href="https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/" target="_blank" rel="noreferrer">971. 翻转二叉树以匹配先序遍历</a></li><li><a href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noreferrer">987. 二叉树的垂序遍历</a></li><li><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noreferrer">863. 二叉树中所有距离为 K 的结点</a></li><li><a href="https://leetcode-cn.com/problems/successor-lcci/" target="_blank" rel="noreferrer">面试题 04.06. 后继者</a></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>树的题目一种中心点就是<strong>遍历</strong>，这是搜索问题和修改问题的基础。</p><p>而遍历从大的方向分为<strong>广度优先遍历和深度优先遍历</strong>，这就是我们的<strong>两个基本点</strong>。两个基本点可以进一步细分，比如广度优先遍历有带层信息的和不带层信息的（其实只要会带层信息的就够了）。深度优先遍历常见的是前序和后序，中序多用于二叉搜索树，因为二叉搜索树的中序遍历是严格递增的数组。</p><p>树的题目从大的方向上来看就三种，一种是搜索类，这类题目最多，这种题目牢牢把握<strong>开始点，结束点 和 目标即可</strong>。构建类型的题目我之前的专题以及讲过了，一句话概括就是<strong>根据一种遍历结果确定根节点位置，根据另外一种遍历结果（如果是二叉搜索树就不需要了）确定左右子树</strong>。修改类题目不多，这种问题边界需要特殊考虑，这是和搜索问题的本质区别，可以使用虚拟节点技巧。另外搜索问题，如果返回值不是根节点也可以考虑虚拟节点。</p><p>树有四个比较重要的对做题帮助很大的概念，分别是完全二叉树，二叉搜索树，路径和距离，这里面相关的题目推荐大家好好做一下，都很经典。</p><p>最后我给大家介绍了七种干货技巧，很多技巧都说明了在什么情况下可以使用。好不好用你自己去找几个题目试试就知道了。</p></div></div></main><footer class="VPDocFooter" data-v-800b61a0 data-v-69c4852c><div class="edit-info" data-v-69c4852c><div class="last-updated" data-v-69c4852c><p class="VPLastUpdated" data-v-69c4852c data-v-d326f0bd>最后编辑时间: <time data-v-d326f0bd>2024-05-09</time></p></div></div><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-da40f255 data-v-a6ae6435><div class="container" data-v-a6ae6435><p class="message" data-v-a6ae6435>Version 4.1 (framework-1.1.4)</p><p class="copyright" data-v-a6ae6435>Copyright © 2014-present Wolfx 🐺</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"docs_backend_accelerate-pip3-in-china.md\":\"DjdCPJFq\",\"docs_backend_accelerate-gradle-in-china.md\":\"CGkcyoNK\",\"docs_backend_docker-note-3.md\":\"CQl409zu\",\"docs_backend_jenkins-guide.md\":\"BZIGBOBi\",\"docs_backend_set-ff-dns-cache.md\":\"CuUX6JOT\",\"docs_backend_spark-note.md\":\"02_JXXxE\",\"docs_backend_docker-nuxt.md\":\"C_6PvfwL\",\"docs_backend_rust-env-note.md\":\"BU_OAV4t\",\"docs_backend_tomcat-note.md\":\"Vr4tUTbZ\",\"docs_backend_frp-guide.md\":\"DDU2HHWH\",\"docs_backend_close-notice-in-php.md\":\"D5GHYrbV\",\"docs_frontend_canvas_fabric.md\":\"AOy_R7I5\",\"docs_database_redis-remote-access.md\":\"Bzo5TeYj\",\"docs_backend_docker-note.md\":\"ChZGBT19\",\"docs_frontend_3d_blender-02-modify.md\":\"CAVENKi3\",\"docs_backend_py-yolox.md\":\"BRID0cyD\",\"docs_database_mysql-faq.md\":\"B7YVX5Jp\",\"docs_backend_docker-note-2.md\":\"CL_KqDai\",\"docs_frontend_3d_blender-01-basic.md\":\"BnmEMv8d\",\"docs_frontend_canvas_canvas-note2.md\":\"W4Ao3Fp5\",\"docs_backend_py-pyautogui.md\":\"CVbowxVi\",\"docs_backend_hadoop-note.md\":\"C0Zkj1Aq\",\"docs_frontend_hybird_cordova-dev-note-01.md\":\"CJNP4RHi\",\"docs_frontend_javascript_js-get-img-base64.md\":\"CT3xLr72\",\"docs_frontend_css_webkit-font-smoothing.md\":\"DFD6fSd_\",\"docs_frontend_framework_react-custom-img.md\":\"CNtPgdKd\",\"docs_frontend_framework_optimize-after-create-react-app.md\":\"DHuM187e\",\"docs_frontend_css_css-text-overflow.md\":\"BvANUV9M\",\"docs_database_mongodb-note.md\":\"CzbCtZdn\",\"docs_frontend_javascript_js-params.md\":\"CPply87o\",\"docs_frontend_css_custom-scrollbar.md\":\"C2mJJ0Br\",\"docs_frontend_ohos_006-napi.md\":\"DbZnOnTu\",\"docs_frontend_javascript_js-excel-export.md\":\"Br59FZ4s\",\"docs_leetcode_0056.merge-intervals.md\":\"BtIvYllA\",\"docs_leetcode_0022.generate-parentheses.md\":\"CKJ9ChWv\",\"docs_frontend_tool_ajax-on-fs-in-chrome.md\":\"S-RLosyR\",\"docs_frontend_canvas_d3-map.md\":\"R7B3i5cq\",\"docs_frontend_html_disable-video-full-screen-ios.md\":\"DA00wnPy\",\"docs_frontend_javascript_js-event-popstate.md\":\"CzciQE3W\",\"docs_frontend_javascript_js-chgcase.md\":\"CNwmFpcT\",\"docs_frontend_3d_blender-03-modeling.md\":\"CWS_Z_Kn\",\"docs_frontend_hybird_cordova-dev-note-07.md\":\"CKyoTXGj\",\"docs_frontend_framework_vue2-editor-note.md\":\"DCV9U76O\",\"docs_leetcode_0003.longest-substring-without-repeating-characters.md\":\"BtV8LyoZ\",\"docs_leetcode_0080.remove-duplicates-from-sorted-array-ii.md\":\"CCR0MUha\",\"docs_leetcode_0096.unique-binary-search-trees.md\":\"DfFEpb5D\",\"docs_frontend_canvas_phaser-ce-note.md\":\"WBhXMW7w\",\"docs_leetcode_0020.valid-parentheses.md\":\"Bnm0R-am\",\"docs_frontend_html_disable-chrome-autocomplete.md\":\"DamxAucq\",\"docs_leetcode_0106.construct-binary-tree-from-preorder-and-inorder-traversal.md\":\"DYzSTXBy\",\"docs_leetcode_0085.maximal-rectangle.md\":\"Chnl5XKU\",\"docs_database_mysql-sql-adv-guide.md\":\"DmX5hA_I\",\"docs_frontend_html_html-encode-and-decode.md\":\"CbJ0v-jM\",\"docs_frontend_javascript_js-word-counter.md\":\"EqlaDey-\",\"docs_database_es-note-01.md\":\"CTz6XSNh\",\"docs_frontend_javascript_js-load-async.md\":\"CQnC3hPc\",\"docs_leetcode_0032.longest-valid-parentheses.md\":\"DH5XXCIk\",\"docs_frontend_hybird_flutter-note-2.md\":\"D1br4jA9\",\"docs_leetcode_0091.decode-ways.md\":\"CjAnmZG6\",\"docs_frontend_tool_gulp-frequently-plugins.md\":\"H3CIZzS-\",\"docs_frontend_hybird_ios-cert.md\":\"CoIljx4e\",\"docs_frontend_javascript_js-route-algorithm.md\":\"hTLjx9EA\",\"docs_leetcode_0021.merge-two-sorted-lists.md\":\"BBqcTvbi\",\"docs_leetcode_0516.longest-palindromic-subsequence.md\":\"RFOAFxKA\",\"docs_frontend_hybird_weapps-async-await.md\":\"1fU5DV5c\",\"docs_frontend_canvas_laya-compile.md\":\"HRz4gttR\",\"docs_frontend_css_disable-copy-using-css.md\":\"CxIa1qa6\",\"docs_frontend_hybird_cordova-dev-note-02.md\":\"BRxg7FHp\",\"docs_frontend_hybird_android-note.md\":\"DIeXipyi\",\"docs_leetcode_0090.subsets-ii.md\":\"BnVFCOmn\",\"docs_frontend_tool_webpack-multi-cores-optmise.md\":\"Db0MiqeS\",\"docs_leetcode_0105.construct-binary-tree-from-inorder-and-postorder-traversal.md\":\"CP2JGYuG\",\"docs_leetcode_0814.md\":\"UZJ3pXXr\",\"docs_frontend_javascript_regexps-note.md\":\"BAml6nrY\",\"docs_frontend_framework_global-component.md\":\"D7j_vWP8\",\"docs_frontend_javascript_gen-uuid-by-js.md\":\"CeD1VmX_\",\"docs_backend_nginx-note.md\":\"WGEqP_xZ\",\"docs_frontend_hybird_h5plus-mui-faq.md\":\"KEeLjJBL\",\"docs_frontend_html_disable-iframe-reference.md\":\"C5p4XgZd\",\"docs_leetcode_0005.longest-palindromic-substring.md\":\"BD9BbYTg\",\"docs_frontend_html_html-head.md\":\"DwvA-Vxx\",\"docs_frontend_javascript_js-copy-to-clipboard.md\":\"B74uCEhQ\",\"docs_frontend_javascript_remove-console.md\":\"Bn1OH0yV\",\"docs_frontend_html_operations-of-frames.md\":\"DKkMgavo\",\"docs_os_win-bugs.md\":\"CkS9BW_g\",\"docs_os_win-powershell-note.md\":\"BebTPsLN\",\"docs_os_macos-faq.md\":\"DQ01vqMK\",\"docs_os_win-remote-desktop-error.md\":\"Vx1sSuNV\",\"docs_leetcode_0061.rotate-list.md\":\"CRogTor3\",\"docs_leetcode_0198.house-robber.md\":\"COm8t5vm\",\"docs_leetcode_0011.container-with-most-water.md\":\"C_Q1ZGi7\",\"docs_frontend_html_the-width-in-browser.md\":\"BF72_RWd\",\"pages_leetcode.md\":\"om2f_BkU\",\"pages_ohos.md\":\"C2JAuDd1\",\"docs_frontend_hybird_cordova-dev-note-05.md\":\"CUOZEs2E\",\"docs_other_gitlab-note.md\":\"CER__Hxj\",\"docs_frontend_framework_nuxt-build-note.md\":\"BkGBR4sc\",\"docs_leetcode_0110.md\":\"ZQ8XgmgY\",\"docs_leetcode_0024.swapnodesinpairs.md\":\"C99hIx15\",\"docs_os_linux-centos-8-faq.md\":\"BzBdg2Gu\",\"docs_frontend_hybird_tauri-subwindow.md\":\"DKr9WjAT\",\"docs_leetcode_0081.search-in-rotated-sorted-array-ii.md\":\"Bku2IW0x\",\"docs_leetcode_0079.word-search.md\":\"CQ3bz_LP\",\"docs_leetcode_0052.n-queens-ii.md\":\"CY_VQ_l3\",\"docs_leetcode_0065.valid-number.md\":\"CdLkz9vV\",\"docs_os_linux-del-file-by-date.md\":\"BYwsItSQ\",\"docs_os_linux-vpn.md\":\"DNnCn4YV\",\"docs_frontend_hybird_flutter-note-1.md\":\"TN90RNqo\",\"docs_frontend_javascript_js-random-funcs.md\":\"BeQxxame\",\"docs_leetcode_0025.reverse-nodes-in-k-groups.md\":\"xSvZT8KX\",\"docs_leetcode_0075.sort-colors.md\":\"CkfxdP9-\",\"docs_leetcode_0212.word-search-ii.md\":\"CdqVOA-U\",\"docs_leetcode_thinkings_backtrack.md\":\"BqFJtOFS\",\"docs_leetcode_0063.unique-paths-ii.md\":\"Bneec9Zp\",\"docs_frontend_ohos_005-atom-service.md\":\"CSU9yvF8\",\"docs_os_linux-pip.md\":\"C3Sn054v\",\"docs_leetcode_0208.implement-trie-prefix-tree.md\":\"Bg9oPmY8\",\"docs_leetcode_0019.removenthnodefromendoflist.md\":\"BXUB8kaK\",\"docs_frontend_canvas_egret-note.md\":\"CjdASkLX\",\"docs_os_linux-traceroute.md\":\"GL8XZ2dI\",\"docs_leetcode_0226.invert-binary-tree.md\":\"QxdHbBNM\",\"docs_leetcode_0078.subsets.md\":\"Ca8FW659\",\"docs_leetcode_0472.concatenated-words.md\":\"CT0KQ57S\",\"docs_leetcode_0108.convert-sorted-array-to-binary-search-tree.md\":\"DpvXrF1r\",\"docs_leetcode_0088.merge-sorted-array.md\":\"CDYu4AGr\",\"docs_leetcode_0023.merge-k-sorted-lists.md\":\"DhLDRw0V\",\"docs_leetcode_0199.binary-tree-right-side-view.md\":\"Dpzydwfv\",\"docs_leetcode_0121.best-time-to-buy-and-sell-stock.md\":\"cvdSyz-w\",\"docs_leetcode_0230.kth-smallest-element-in-a-bst.md\":\"KrEA1LHl\",\"docs_other_change-edge-cache.md\":\"DTecVa_Y\",\"docs_os_linux-ssh-without-password.md\":\"zTST6V0Q\",\"docs_os_linux-zip-unreadable.md\":\"DlBFgVHn\",\"docs_leetcode_0109.convert-sorted-list-to-binary-search-tree.md\":\"C9jkJHjb\",\"docs_leetcode_1382.md\":\"C2Rzyq2R\",\"docs_leetcode_0206.reverse-linked-list.md\":\"CnEw0IZJ\",\"docs_leetcode_0102.binary-tree-level-order-traversal.md\":\"BqctxmEE\",\"docs_frontend_hybird_react-native-navigation.md\":\"Dk8ksODY\",\"docs_leetcode_0046.permutations.md\":\"BvMxicUV\",\"docs_os_linux-ubuntu-faq.md\":\"CCUx46Hr\",\"docs_leetcode_0002.add-two-numbers.md\":\"Db9YpnPL\",\"docs_frontend_javascript_document-activeelement.md\":\"CtEvrtwr\",\"docs_frontend_canvas_canvas-note.md\":\"nsckBVGi\",\"docs_index.md\":\"CSe7LMTC\",\"docs_leetcode_0695.max-area-of-island.md\":\"-vqP-BSz\",\"docs_os_wget-download-full-website.md\":\"4N6YoGv5\",\"docs_leetcode_0122.best-time-to-buy-and-sell-stock-ii.md\":\"CWlhUBHF\",\"docs_leetcode_0154.find-minimum-in-rotated-sorted-array-ii.md\":\"C7bpQi1I\",\"docs_frontend_javascript_js-check-is-img-exists.md\":\"CeQtp6zs\",\"docs_leetcode_0978.longest-turbulent-subarray.md\":\"FFUhQqoO\",\"docs_leetcode_0086.partition-list.md\":\"Dvuo5A2h\",\"docs_leetcode_0026.remove-duplicates-from-sorted-array.md\":\"DPEq6Him\",\"docs_frontend_html_html5-tel.md\":\"DqdwYars\",\"docs_leetcode_0518.coin-change-2.md\":\"DfQ2IqmN\",\"docs_frontend_ohos_007-flutter-plugin.md\":\"0Aoul_Ou\",\"docs_leetcode_0200.number-of-islands.md\":\"D353v8nl\",\"docs_frontend_css_css-nth-child.md\":\"DmbHJH9p\",\"docs_os_linux-centos-disk-extend.md\":\"BHJFVtkW\",\"docs_leetcode_0337.house-robber-iii.md\":\"CFi6JNVl\",\"docs_other_git-guide.md\":\"GNkI6Njl\",\"docs_os_pxe-guide.md\":\"CENoQ8CP\",\"docs_other_use-redirector-plugin.md\":\"D4uH6cvJ\",\"docs_os_win-watch-port.md\":\"CNBYFrh6\",\"docs_nodejs_node-cli-framework.md\":\"CZhppTJ1\",\"docs_leetcode_0050.pow-x-n.md\":\"D6GJr2-T\",\"docs_frontend_hybird_cordova-dev-note-06.md\":\"ke272ahY\",\"docs_leetcode_0074.search-a-2d-matrix.md\":\"DjE8U7YW\",\"docs_leetcode_0094.binary-tree-inorder-traversal.md\":\"Dnbxu-7k\",\"docs_leetcode_0816.ambiguous-coordinates.md\":\"C2LOeLMb\",\"docs_leetcode_0042.trapping-rain-water.md\":\"BFDdeapa\",\"docs_nodejs_node-static-file-server.md\":\"CroU6bnP\",\"docs_database_pd-ch-bugs-in-reverse.md\":\"0ZvpuuXm\",\"docs_nodejs_node-schedule.md\":\"_vi3iji4\",\"docs_nodejs_nodejs-exec-with-tail-exe.md\":\"Bs9WcAXu\",\"docs_backend_qt-cpp-note.md\":\"oTZnmRej\",\"docs_nodejs_node-pkg-manager-note.md\":\"B0xGidXI\",\"docs_leetcode_0309.best-time-to-buy-and-sell-stock-with-cooldown.md\":\"D8ni9iQH\",\"docs_nodejs_node-pm2.md\":\"DxVcWSF_\",\"docs_leetcode_0365.water-and-jug-problem.md\":\"CyTmgvmp\",\"docs_nodejs_nodejs-md5-support-chinese.md\":\"BtcL2Heh\",\"docs_frontend_css_ios-keyboard-scroll-bug.md\":\"5Qwn7Cqi\",\"docs_frontend_html_html5-file-api.md\":\"RL5gGWQf\",\"docs_nodejs_nodejs-nvm.md\":\"DegJTZcY\",\"docs_nodejs_nodejs-http-proxy.md\":\"BqOXLte7\",\"docs_nodejs_nodejs-blockchain.md\":\"DRKLTZWg\",\"docs_leetcode_1658.minimum-operations-to-reduce-x-to-zero.md\":\"xwYz3KM6\",\"docs_leetcode_0104.maximum-depth-of-binary-tree.md\":\"DJfvxLSY\",\"docs_leetcode_1325.md\":\"wqeo2DvY\",\"docs_leetcode_0131.palindrome-partitioning.md\":\"Cx0fPg3_\",\"docs_nodejs_nodejs-read-file-list.md\":\"DqtSshzX\",\"docs_frontend_hybird_react-native-env.md\":\"BelFxnn8\",\"docs_frontend_css_mobile-css-compatible.md\":\"DNctygfL\",\"docs_leetcode_0145.binary-tree-postorder-traversal.md\":\"YFo2GHA3\",\"docs_frontend_canvas_d3-simple-custom-bar.md\":\"DhNeTbAt\",\"docs_leetcode_0147.insertion-sort-list.md\":\"Iyg-5erF\",\"docs_leetcode_0144.binary-tree-preorder-traversal.md\":\"QFwAEhWF\",\"docs_leetcode_0039.combination-sum.md\":\"CHGu6Xtz\",\"docs_leetcode_0033.search-in-rotated-sorted-array.md\":\"BPelG6SW\",\"docs_nodejs_puppeteer-start-guide.md\":\"8BkVjEwT\",\"docs_nodejs_watch-port-by-nodejs.md\":\"D-wuO9uY\",\"docs_os_linux-deepin-note.md\":\"gudTO8HA\",\"docs_frontend_javascript_fe-js-image-compress.md\":\"CFao4mIR\",\"docs_frontend_ohos_004-media.md\":\"cx5G2rRG\",\"docs_leetcode_91_laoshushidu.md\":\"C17iYDBB\",\"docs_frontend_javascript_similar-objects-in-js.md\":\"CZlguaob\",\"docs_frontend_javascript_js-chinese-num-upper-case.md\":\"C2umygKl\",\"docs_os_linux-kill-process.md\":\"CbAlLUwc\",\"docs_leetcode_0030.substring-with-concatenation-of-all-words.md\":\"DKn_qOEA\",\"docs_leetcode_0322.coin-change.md\":\"C_m8WnlU\",\"docs_leetcode_0886.possible-bipartition.md\":\"B9x0K__M\",\"docs_os_linux-cmds.md\":\"o81LEGfe\",\"docs_leetcode_91_binary-search.md\":\"Bd3XZu7z\",\"docs_leetcode_0092.reverse-linked-list-ii.md\":\"CPgXhIHI\",\"docs_leetcode_0416.partition-equal-subset-sum.md\":\"D4GqR73M\",\"docs_leetcode_0211.add-and-search-word-data-structure-design.md\":\"Bee4JvkN\",\"index.md\":\"BmGdzXvy\",\"docs_frontend_tool_vscode-config-template.md\":\"Dghju3ph\",\"docs_leetcode_0139.word-break.md\":\"YYikCq4a\",\"docs_frontend_css_css-bfc.md\":\"DAW_6zxM\",\"docs_frontend_html_html5-m3u8.md\":\"_AO5QkFy\",\"docs_leetcode_0152.maximum-product-subarray.md\":\"11CpYpd1\",\"docs_other_cloc.md\":\"xpcrD3rh\",\"docs_frontend_hybird_cordova-dev-note-03.md\":\"BZSdFOhk\",\"docs_backend_docker-note-4.md\":\"CFsYJDpN\",\"docs_leetcode_0820.short-encoding-of-words.md\":\"BFBWZBje\",\"docs_frontend_javascript_reload-replace-and-href.md\":\"BelUiBN6\",\"docs_frontend_canvas_createjs-note.md\":\"C4_8INuT\",\"docs_leetcode_0959.regions-cut-by-slashes.md\":\"Dvkdb3t-\",\"docs_leetcode_0150.evaluate-reverse-polish-notation.md\":\"w_QeDRt4\",\"docs_leetcode_0029.divide-two-integers.md\":\"BQv-lKN7\",\"docs_leetcode_0062.unique-paths.md\":\"ij8wVywL\",\"docs_leetcode_0101.symmetric-tree.md\":\"BNsl3lsz\",\"docs_leetcode_0060.permutation-sequence.md\":\"CgDKl5O-\",\"docs_os_linux-arch-faq-wiki.md\":\"CFDC6Q1d\",\"docs_frontend_javascript_es6-arraybuffer.md\":\"Cm6pENf6\",\"docs_leetcode_0124.binary-tree-maximum-path-sum.md\":\"BH5AonWR\",\"docs_frontend_javascript_js-geo-distance.md\":\"5fYfQWjz\",\"docs_os_linux-manjaro-optimize.md\":\"BpWB6ffG\",\"docs_leetcode_thinkings_balanced-tree.md\":\"Ba2FL1RF\",\"docs_frontend_framework_vue2-to-vue3-tips.md\":\"aJmXUgxX\",\"docs_leetcode_0785.is-graph-bipartite.md\":\"DR6QB5kY\",\"docs_leetcode_0889.construct-binary-tree-from-preorder-and-postorder-traversal.md\":\"BIQMJYBy\",\"docs_frontend_javascript_js-merge-region.md\":\"B1qhhJqc\",\"docs_other_webstorm-conf-log4js.md\":\"DH5XFfHl\",\"docs_leetcode_0073.set-matrix-zeroes.md\":\"Q-JRsR9l\",\"docs_frontend_javascript_js-rxjs-note.md\":\"C1cmyOyl\",\"docs_frontend_hybird_cordova-dev-note-04.md\":\"DUDVJYqN\",\"docs_frontend_ohos_003-context-and-path.md\":\"0xJEcmnY\",\"docs_frontend_javascript_seajs-useful-funs.md\":\"BbAHwOSV\",\"docs_leetcode_0055.jump-game.md\":\"BYrJ6EuP\",\"docs_os_linux-install-services.md\":\"-ink29u0\",\"docs_frontend_javascript_js-compare-ver.md\":\"BlF0NZFR\",\"docs_os_linux-checkinstall-note.md\":\"_IlcLF1D\",\"docs_leetcode_0049.group-anagrams.md\":\"DoOk-eYv\",\"docs_frontend_ohos_001-pkg.md\":\"3pXGAgx-\",\"docs_frontend_javascript_js-closure.md\":\"C_LEKpcL\",\"docs_rust_rust-000.md\":\"C2w_Qc0F\",\"docs_os_linux-iptables-proxy.md\":\"cyBACd-S\",\"docs_leetcode_0057.insert-interval.md\":\"B78dt5iK\",\"docs_leetcode_0100.same-tree.md\":\"CSNGiPS5\",\"docs_leetcode_0103.binary-tree-zigzag-level-order-traversal.md\":\"Dd8zmUg0\",\"docs_leetcode_0084.largest-rectangle-in-histogram.md\":\"BbglNOF8\",\"docs_os_linux-centos-6-to-7.md\":\"B-qwmaz2\",\"docs_leetcode_0047.permutations-ii.md\":\"CTVilTEA\",\"docs_leetcode_0017.letter-combinations-of-a-phone-number.md\":\"DfKKzXq1\",\"docs_leetcode_0015.3sum.md\":\"WUI1_2Lq\",\"docs_leetcode_thinkings_graph.md\":\"dIQy2nyy\",\"docs_leetcode_thinkings_greedy.md\":\"C6sfPWig\",\"docs_leetcode_thinkings_dfs.md\":\"DVa0mG0n\",\"docs_leetcode_1032.stream-of-characters.md\":\"Ct8OuQNa\",\"docs_frontend_hybird_replace-electron.md\":\"DNxGq07h\",\"docs_frontend_javascript_gps-coordinate-transofrm.md\":\"D54r2RBA\",\"docs_leetcode_0045.jump-game-ii.md\":\"Bs-83o3Y\",\"docs_os_linux-watch-running-state.md\":\"2fNRCX_E\",\"docs_leetcode_0087.scramble-string.md\":\"Bj48AKPa\",\"docs_leetcode_0130.surrounded-regions.md\":\"Cy_lAn1P\",\"docs_frontend_javascript_jquery-qrcode-chinese-problem.md\":\"BLY7niqs\",\"docs_frontend_ohos_002-utils.md\":\"stmQy-o5\",\"docs_leetcode_0128.longest-consecutive-sequence.md\":\"CGQC0p4t\",\"pages_about.md\":\"CZW-Ca3E\",\"docs_leetcode_thinkings_trie.md\":\"CsAMuTUR\",\"docs_leetcode_thinkings_basic-data-structure.md\":\"CL1_uXKE\",\"docs_leetcode_thinkings_linked-list.md\":\"DGeposAk\",\"docs_leetcode_0155.min-stack.md\":\"DvELQJJ-\",\"docs_leetcode_1024.video-stitching.md\":\"D_sUqOwj\",\"docs_leetcode_0048.rotate-image.md\":\"J3bBfT4Z\",\"docs_leetcode_0053.maximum-sum-subarray.md\":\"ClVpLPB4\",\"docs_nodejs_html5-live-video.md\":\"BlUBWOiy\",\"docs_leetcode_thinkings_island.md\":\"xiJ0b1Jr\",\"docs_os_linux-tar-backup.md\":\"C_AA1Qwx\",\"docs_leetcode_0875.koko-eating-bananas.md\":\"C0ZrWRnZ\",\"docs_frontend_javascript_table-colspan-convert.md\":\"C_UxjHq7\",\"docs_leetcode_thinkings_binary-tree-traversal.md\":\"D8H14Rrr\",\"docs_leetcode_0095.unique-binary-search-trees-ii.md\":\"jk8a-7UB\",\"docs_leetcode_0113.path-sum-ii.md\":\"DC5lLayp\",\"docs_leetcode_0153.find-minimum-in-rotated-sorted-array.md\":\"CAdSqNek\",\"docs_other_aria2-cmds.md\":\"DoWhVWz3\",\"docs_leetcode_thinkings_slide-window.md\":\"Dqn8Axse\",\"docs_leetcode_0004.median-of-two-sorted-arrays.md\":\"DJdGeX3e\",\"docs_frontend_ohos_000-base.md\":\"C9o3dT2t\",\"docs_leetcode_0142.linked-list-cycle-ii.md\":\"BUqprxx_\",\"docs_leetcode_0001.two-sum.md\":\"DeikvjKN\",\"docs_nodejs_webpack-umd-pkg.md\":\"Bc9QTCy5\",\"docs_leetcode_0401.binary-watch.md\":\"BmXA2oSd\",\"docs_leetcode_1255.maximum-score-words-formed-by-letters.md\":\"CSd52xYQ\",\"docs_leetcode_0125.valid-palindrome.md\":\"4Kl27skH\",\"docs_leetcode_0295.find-median-from-data-stream.md\":\"BpVk7vMU\",\"docs_frontend_hybird_cordova-dev-note-08.md\":\"-FJhYP34\",\"docs_leetcode_0040.combination-sum-ii.md\":\"0QxJgaTW\",\"docs_nodejs_nodejs-spider-for-gb2312.md\":\"D1CMLA_m\",\"docs_leetcode_1953.md\":\"YSx3fvaZ\",\"docs_leetcode_0129.sum-root-to-leaf-numbers.md\":\"BP0ajn2C\",\"docs_leetcode_1326.minimum-number-of-taps-to-open-to-water-a-garden.md\":\"DJUXVGB4\",\"docs_leetcode_0066.plus-one.md\":\"BIHkXuia\",\"docs_frontend_javascript_web-worker.md\":\"BIsC8cZL\",\"docs_leetcode_0031.next-permutation.md\":\"Dw6IjutT\",\"docs_leetcode_0140.word-break-ii.md\":\"BL22j0yS\",\"docs_os_linux-centos-7-faq.md\":\"B4LMc1Md\",\"docs_leetcode_0098.validate-binary-search-tree.md\":\"D0a-DUR_\",\"docs_frontend_hybird_react-native-tips.md\":\"CGTjt9yJ\",\"docs_leetcode_thinkings_tree.md\":\"BjIvGzm_\",\"docs_leetcode_thinkings_dynamic-programming.md\":\"DdPoS-8e\",\"docs_other_math.md\":\"CgC7Hk2W\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"zh-CN\",\"dir\":\"ltr\",\"title\":\"Wolfx's Notebook\",\"description\":\"Wolfx's Notebook\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":\"force-dark\",\"themeConfig\":{\"siteTitle\":\"Wolfx's Notebook\",\"darkModeSwitchLabel\":\"夜间模式\",\"sidebarMenuLabel\":\"目录\",\"outline\":\"deep\",\"outlineTitle\":\"大纲(Outline)\",\"returnToTopLabel\":\"返回顶部\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Notes\",\"link\":\"/docs/\"},{\"text\":\"OpenHarmony\",\"link\":\"/pages/ohos\"},{\"text\":\"LeetCode\",\"link\":\"/pages/leetcode\"},{\"text\":\"About\",\"link\":\"/pages/about\"}],\"sidebar\":[],\"search\":{\"provider\":\"algolia\",\"options\":{\"appId\":\"HZ9Y1ODREP\",\"apiKey\":\"a94210862448c76041d2ff708f8f3e47\",\"indexName\":\"wolfx\"}},\"footer\":{\"message\":\"Version 4.1 (framework-1.1.4)\",\"copyright\":\"Copyright © 2014-present Wolfx 🐺\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>