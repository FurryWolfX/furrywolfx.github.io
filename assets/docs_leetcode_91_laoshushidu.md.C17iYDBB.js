import{_ as s,c as a,o as i,a4 as e}from"./chunks/framework.VzvPGsLx.js";const u=JSON.parse('{"title":"从老鼠试毒问题来看二分法","description":"","frontmatter":{"title":"从老鼠试毒问题来看二分法","date":"2024-05-05T00:00:00.000Z","tags":["LeetCode"]},"headers":[],"relativePath":"docs/leetcode/91/laoshushidu.md","filePath":"docs/leetcode/91/laoshushidu.md"}'),n={name:"docs/leetcode/91/laoshushidu.md"},t=e(`<h1 id="从老鼠试毒问题来看二分法" tabindex="-1">从老鼠试毒问题来看二分法 <a class="header-anchor" href="#从老鼠试毒问题来看二分法" aria-label="Permalink to &quot;从老鼠试毒问题来看二分法&quot;">​</a></h1><p>很多人对于二分法的理解比较片面，之前碰到一个题目 &quot; 从一个先升序后降序的数列中，比如 1 2 3 7 4 3 2 中运用二分法去查找一个给定的元素&quot;，很多人说根本不能二分，因为没有排序。其实 这道题完全可以使用二分查找进行解答， 如果你觉得不可以的话，很可能对二分法理解还比较片面。 这里以另外一个更加有趣（至少我认为）的例子来讲解一下二分法。</p><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p>面试题：有 1000 个一模一样的瓶子，其中有 1 瓶是毒药，老鼠喝了有毒的会在 24h 之后死亡。求最少需要多少老鼠才能在 24h 里找到有毒的那瓶。</p><h2 id="解法" tabindex="-1">解法 <a class="header-anchor" href="#解法" aria-label="Permalink to &quot;解法&quot;">​</a></h2><p>这道题的解法有很多，今天我们来聊下用二分法来解这道题。这道题似乎和我们看的常见的二分法有很大的区别，但是仔细想一下， 二分法本质是将问题的规模缩小到原有的一半。类似的，三分法就是将问题规模缩小为原来的 1/3,带着这样的思想我们再来看一下。</p><p>我们先对 1000 个瓶子进行编号，从 1-1000 这样子。不过我们不是通过我们大家平时生活中使用的十进制，而是使用在计算机中使用的二进制， 同时让大家感受一下二进制的魅力。</p><p>为了方便讲解，我们假设不是 1000 个瓶子，而是 4 个。</p><p>我们来编一下号：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">00</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">01</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #2</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #3</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// #4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们的目标是找到哪个瓶子有毒，换句话说我们目标是找到有毒瓶子的编号，再换句话说我们的目标是 找到有毒瓶子的 2 个 bit 分别是什么，是 0 还是 1.</p><p>比如有毒的是 3 号瓶子，那么我们就是想确认第一个 bit 是 0，第二个 bit 是 1，即 11，转化为 10 进制就是 3 号。</p><p>那么如何确定每一个 bit 是什么呢？ 回想一下，我们手上有老鼠，老鼠有两个 state，alive 或者 died，这就是我们拥有的全部。</p><p>接下来我们逐一对瓶子进行分组，分组的依据就是每一个 bit 的值。</p><p>比如:</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 00 01     #g1:1  第一个bit是0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 10 11     #g1:2  第一个bit是1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 00 10     #g2:1  第二个bit是0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 01 11     #g2:2  第二个bit是1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们来找第一个老鼠#1 来喝 g:1:1, 如果他死了，那么毒就在这一组，也就是说毒的第一个 bit 是 0，否则是 1</p><p>我们来找第二个老鼠#2 来喝 g:2:1, 如果他死了，那么毒就在这一组，也就是说毒的第二个 bit 是 0，否则是 1</p><p>所以我们可以看出, 两只老鼠就搞定了，我们按照这个思路，可以出 1000 个瓶子只需要 10 个瓶子, 即 log2 1000， 2 的 10 次方是 1024，因此 10 个老鼠够了，如果 1025 个瓶子的话，就需要 11 个老鼠了。</p><p>如果你仔细思考的话，不难看出，我们是在用老鼠喝了水之后的反应（生或死）来进行判断每一个 bit 的数字，不管生死，我们总能得出这个 bit 的值，是 0 还是 1. 因此每使用一只老鼠我们都将问题规模缩小为原来的 1／2. 这是典型的二分法。</p><h2 id="这是最优解么" tabindex="-1">这是最优解么 <a class="header-anchor" href="#这是最优解么" aria-label="Permalink to &quot;这是最优解么&quot;">​</a></h2><p>是的，这是最优解，如果你愿意用严格的数学来证明的话，你可以试一下数学归纳法。 如果你想感性的判断一下的话，可以继续往下读。</p><p>什么是最优解？ 最优解就是要让未知世界无机可乘，也就是说在最坏的情况下得到最优（现实世界都是未知的）。上面的例子，不管小老鼠是生还是死，我们都可以将问题规模缩小到 1/2. 也就是说最坏的情况就是最好的情况，也就是说没有最坏情况。</p><p>那么我们是否可以将问题规模缩小的 1／3 或者更小呢？</p><h2 id="我们可以三分么" tabindex="-1">我们可以三分么 <a class="header-anchor" href="#我们可以三分么" aria-label="Permalink to &quot;我们可以三分么&quot;">​</a></h2><p>简单来说，不可以， 因为老鼠只有两种 observable state， 即 alive， died. 假如我们有 10 个小球，其中有一个是异常的，其他 9 个都是一样的，我们怎么才能通过最少的称量来确定是哪一个异常，是重还是轻？这个时候我们就可以使用三分法了，为什么？因为天平有三个 state， 平衡，左倾，右倾，使得我们”有可能“ 将问题规模缩小为 1/3， 事实上，确实可以实现将问题规模缩小到 1/3。</p><p>我会在之后的文章中进行讲解小球的问题最优策略， 并解释为什么这是最优策略。</p><h2 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h2><p>基于比较的排序都无法逃脱 nlogn 时间复杂度的命运，这是为什么？能否利用本篇文章的思想进行解释？</p>`,29),p=[t];function l(h,r,d,o,c,k){return i(),a("div",null,p)}const g=s(n,[["render",l]]);export{u as __pageData,g as default};
