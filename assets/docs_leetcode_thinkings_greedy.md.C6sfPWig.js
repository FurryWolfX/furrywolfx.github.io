import{_ as e,c as t,o as a,a4 as r}from"./chunks/framework.VzvPGsLx.js";const f=JSON.parse('{"title":"算法专题：贪婪策略","description":"","frontmatter":{"title":"算法专题：贪婪策略","date":"2024-05-05T00:00:00.000Z","tags":["LeetCode"]},"headers":[],"relativePath":"docs/leetcode/thinkings/greedy.md","filePath":"docs/leetcode/thinkings/greedy.md"}'),o={name:"docs/leetcode/thinkings/greedy.md"},i=r('<h1 id="贪婪策略" tabindex="-1">贪婪策略 <a class="header-anchor" href="#贪婪策略" aria-label="Permalink to &quot;贪婪策略&quot;">​</a></h1><p>贪婪策略是一种常见的算法思想。具体是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑。他所做出的是在某种意义上的局部最优解。贪心算法并不是对所有问题都能得到整体最优解，比如硬币找零问题，关键是贪心策略的选择。</p><p>选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关，这点和动态规划一样。贪婪策略和动态规划类似，大多数情况也都是用来处理<code>极值问题</code>。</p><p>LeetCode 上对于贪婪策略有 73 道题目。我们将其分成几个类型来讲解，截止目前我们暂时只提供<code>覆盖</code>问题，其他类型可以期待我的新书或者之后的题解文章。</p><h2 id="覆盖问题" tabindex="-1">覆盖问题 <a class="header-anchor" href="#覆盖问题" aria-label="Permalink to &quot;覆盖问题&quot;">​</a></h2><p>我们挑选三道来讲解，这三道题除了使用贪婪法，你也可以尝试动态规划来解决。</p><ul><li><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noreferrer">45. 跳跃游戏 II</a>，困难</li><li><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noreferrer">1024. 视频拼接</a>，中等</li><li><a href="https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/" target="_blank" rel="noreferrer">1326. 灌溉花园的最少水龙头数目</a>，困难</li></ul><p>覆盖问题的一大特征，我们可以将其抽象为<code>给定数轴上的一个大区间 I 和 n 个小区间 i[0], i[1], ..., i[n - 1]，问最少选择多少个小区间，使得这些小区间的并集可以覆盖整个大区间。</code></p><p>我们来看下这三道题吧。</p><ul><li><a href="./../0045.jump-game-ii.html">45. 跳跃游戏 II</a></li><li><a href="./../1024.video-stitching.html">1024. 视频拼接</a></li><li><a href="./../1326.minimum-number-of-taps-to-open-to-water-a-garden.html">1326. 灌溉花园的最少水龙头数目</a></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>极值问题我们可以考虑使用动态规划和贪心，而覆盖类的问题使用动态规划和贪心都是可以的，只不过使用贪心的代码和复杂度通常都会更简单。但是相应地，贪心的难点在于如何证明局部最优解就可以得到全局最优解。通过这几道题的学习，希望你能够明白覆盖类问题的套路，其底层都是一样的。明白了这些， 你回头再去看覆盖类的题目，或许会发现新的世界。</p>',12),l=[i];function n(c,d,s,h,p,m){return a(),t("div",null,l)}const u=e(o,[["render",n]]);export{f as __pageData,u as default};
