import{_ as o,o as e,c as a,Q as c}from"./chunks/framework.5c044c0e.js";const _=JSON.parse('{"title":"location.reload 与 location.replace 与 location.href","description":"","frontmatter":{"title":"location.reload 与 location.replace 与 location.href","catalog":true,"date":"2016-09-23T16:50:24.000Z","subtitle":null,"header-img":null,"tags":["JavaScript"]},"headers":[],"relativePath":"docs/frontend/javascript/reload-replace-and-href.md","filePath":"docs/frontend/javascript/reload-replace-and-href.md"}'),l={name:"docs/frontend/javascript/reload-replace-and-href.md"},t=c('<h1 id="location-reload-与-location-replace-与-location-href" tabindex="-1">location.reload 与 location.replace 与 location.href <a class="header-anchor" href="#location-reload-与-location-replace-与-location-href" aria-label="Permalink to &quot;location.reload 与 location.replace 与 location.href&quot;">​</a></h1><h2 id="location-reload-与-location-replace" tabindex="-1">location.reload 与 location.replace <a class="header-anchor" href="#location-reload-与-location-replace" aria-label="Permalink to &quot;location.reload 与 location.replace&quot;">​</a></h2><p>在实际应用的时候，重新刷新页面的时候，我们通常使用： <code>location.reload()</code> 或者是 <code>history.go(0)</code> 来做。下面有一些相关的内容，大家看完了就会有更多的收获。</p><p>首先介绍两个方法的语法：</p><p><code>reload</code> 方法，该方法强迫浏览器刷新当前页面。</p><p>语法： <code>location.reload([bForceGet])</code></p><p>参数： bForceGet， 可选参数， 默认为 false，从客户端缓存里取当前页。true, 则以 GET 方式，从服务端取最新的页面，相当于客户端点击 F5(&quot;刷新&quot;)</p><p>replace 方法，该方法通过指定 URL 替换当前缓存在历史里（客户端）的项目，因此当使用 replace 方法之后，你不能通过 “前进” 和“后退”来访问已经被替换的 URL。</p><p>语法： <code>location.replace(URL)</code></p><p>在 实际应用的时候，重新刷新页面的时候，我们通常使用： <code>location.reload()</code> 或者是 <code>history.go(0)</code> 来做。因为这种做法就像是客户端点 F5 刷新页面，所以页面的 <code>method=&quot;post&quot;</code> 的时候，会出现 “网页过期” 的提示。</p><p>那是因为 Session 的安全 保护机制。</p><p>可以想到： 当调用 <code>location.reload()</code> 方法的时候， <code>aspx</code> 页面此时在服务端内存里已经存在， 因此必定是 IsPostback 的。</p><p>如果有这种应用：</p><p>我们需要重新加载该页面，也就是说我们期望页面能够在服务端重新被创建， 我们期望是 Not IsPostback 的。</p><p>这里，<code>location.replace()</code> 就可以完成此任务。被 replace 的页面每次都在服务端重新生成。</p><p>你可以这么写： <code>location.replace(location.href)</code></p><h2 id="location-replace-与-location-href" tabindex="-1">location.replace 与 location.href <a class="header-anchor" href="#location-replace-与-location-href" aria-label="Permalink to &quot;location.replace 与 location.href&quot;">​</a></h2><ol><li><code>window.location.href=&quot;url&quot;</code>：改变 url 地址；</li><li><code>window.location.replace(&quot;url&quot;)</code>：将地址替换成新 url，该方法通过指定 URL 替换当前缓存在历史里（客户端）的项目，因此当使用 replace 方法之后，你不能通过 “前进” 和“后 退”来访问已经被替换的 URL，这个特点对于做一些过渡页面非常有用！</li></ol>',18),r=[t];function n(i,d,p,s,h,f){return e(),a("div",null,r)}const m=o(l,[["render",n]]);export{_ as __pageData,m as default};
