import{_ as o,c as e,o as d,a4 as t}from"./chunks/framework.CWaimgAe.js";const S=JSON.parse('{"title":"Rust 中字符串的 to_owned 和 String::from 的区别","description":"","frontmatter":{"title":"Rust 中字符串的 to_owned 和 String::from 的区别","date":"2024-03-27T00:00:00.000Z","tags":["Rust"]},"headers":[],"relativePath":"docs/other/rust-000.md","filePath":"docs/other/rust-000.md"}'),c={name:"docs/other/rust-000.md"},r=t('<h1 id="rust-中字符串的-to-owned-和-string-from-的区别" tabindex="-1"><code>Rust</code> 中字符串的 <code>to_owned</code> 和 <code>String::from</code> 的区别 <a class="header-anchor" href="#rust-中字符串的-to-owned-和-string-from-的区别" aria-label="Permalink to &quot;`Rust` 中字符串的 `to_owned` 和 `String::from` 的区别&quot;">​</a></h1><p>在 <code>Rust</code> 中，<code>to_owned()</code> 和 <code>String::from()</code> 都是用于将 <code>&amp;str</code> 类型转换为 <code>String</code> 类型的方法，但它们在实现细节和使用场景上有所不同。</p><p>这意味着 <code>to_owned()</code> 方法不仅适用于字符串切片（<code>&amp;str</code>），还适用于任何实现了 <code>ToOwned trait</code> 的类型。当调用 <code>to_owned()</code> 时，它会将数据从栈复制到堆中，创建一个新的 String 实例，该实例拥有数据的所有权。这种方法直观合理，适用于需要明确表示拥有数据所有权的场景。</p><p>另一方面，<code>String::from()</code> 方法是直接在 <code>String</code> 类型上定义的，用于将一个<code>&amp;str</code> 值转换为 <code>String</code> 类型。与 <code>to_owned()</code> 不同，<code>String::from()</code> 不会涉及到数据所有权的转移，它仅仅是创建一个新的 <code>String</code> 实例，其内容与原始的 <code>&amp;str</code> 相同，但不改变数据的所有权 5 。这使得 <code>String::from()</code> 在不需要改变数据所有权的情况下，提供了一种更简洁的方式来创建 <code>String</code> 实例。</p><p>总结来说，<code>to_owned()</code>和 <code>String::from()</code> 都可以将 <code>&amp;str</code> 转换为 <code>String</code>，但 <code>to_owned()</code>涉及到数据所有权的转移，适用于需要明确表示拥有数据所有权的场景；而 <code>String::from()</code> 则提供了一种更简洁的方式来创建 <code>String</code> 实例，不涉及数据所有权的转移。</p><h2 id="相关问题-rust-中-clone-和-to-owned-的区别" tabindex="-1">相关问题：<code>Rust</code> 中 <code>clone()</code> 和 <code>to_owned()</code> 的区别 <a class="header-anchor" href="#相关问题-rust-中-clone-和-to-owned-的区别" aria-label="Permalink to &quot;相关问题：`Rust` 中 `clone()` 和 `to_owned()` 的区别&quot;">​</a></h2><p><code>clone()</code>方法用于复制对象，而<code>to_owned()</code>方法用于创建一个与原对象相同但不指向同一内存地址的新对象。</p>',7),n=[r];function a(s,i,_,m,p,u){return d(),e("div",null,n)}const f=o(c,[["render",a]]);export{S as __pageData,f as default};
